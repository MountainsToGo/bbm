<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bogus Basin Interactive Map</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }
        .container {
            max-width: 1800px;
            margin: 0 auto;
        }
        .header {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        .header h1 {
            color: #667eea;
            margin-bottom: 10px;
        }
        .mode-selector {
            display: flex;
            gap: 15px;
            margin-top: 15px;
        }
        .mode-btn {
            flex: 1;
            padding: 15px;
            border: 3px solid transparent;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-weight: 600;
        }
        .mode-btn.active {
            border-color: #667eea;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            transform: scale(1.05);
        }
        .mode-btn:not(.active) {
            background: #f1f5f9;
            color: #64748b;
        }
        .mode-btn:hover:not(.active) {
            background: #e2e8f0;
        }
        .progress-bar {
            width: 100%;
            height: 30px;
            background: #e2e8f0;
            border-radius: 15px;
            overflow: hidden;
            margin-top: 15px;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ade80 0%, #22c55e 100%);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
        .main-content {
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 20px;
            max-height: calc(100vh - 200px);
            min-height: 500px; /* Ensure minimum scrollable height */
            overflow: visible; /* Allow Safari to show scroll */
        }
        .sidebar {
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            max-height: 1200px; /* Limit sidebar height */
            min-height: 500px; /* Ensure scrollable area */
            overflow-y: visible; /* Let name-list-container handle scroll */
            -webkit-overflow-scrolling: touch;
        }
        .sidebar h2 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 1.2em;
            flex-shrink: 0;
        }
        .current-name {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            text-align: center;
            flex-shrink: 0;
        }
        .current-name .label {
            font-size: 0.85em;
            opacity: 0.9;
            margin-bottom: 3px;
        }
        .current-name .name {
            font-size: 1.5em;
            font-weight: bold;
        }
        .name-list-container {
            flex: 0 1 auto;
            max-height: 675px; /* Show exactly 15 items with scroll */
            height: 675px; /* Fixed height for scroll box */
            min-height: 0; /* Safari flexbox fix */
            overflow-y: scroll; /* Always show scrollbar */
            -webkit-overflow-scrolling: touch; /* Safari smooth scrolling */
            margin-top: 10px;
            padding-right: 5px;
        }
        .name-list-container::-webkit-scrollbar {
            width: 8px;
        }
        .name-list-container::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 10px;
        }
        .name-list-container::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 10px;
        }
        .name-list-container::-webkit-scrollbar-thumb:hover {
            background: #764ba2;
        }
        #namesList {
            width: 100%;
            min-height: 100px; /* Ensure content is visible in Safari */
        }
        .name-list-item {
            padding: 8px 10px;
            margin: 3px 0;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.9em;
            border-left: 4px solid transparent;
        }
        .name-list-item.completed {
            background: #d1fae5;
            border-left-color: #10b981;
            color: #065f46;
            cursor: default;
        }
        .name-list-item.current {
            background: #ddd6fe;
            border-left-color: #667eea;
            font-weight: bold;
            cursor: pointer;
        }
        .name-list-item.current:hover {
            background: #c4b5fd;
            transform: translateX(3px);
        }
        .name-list-item.pending {
            cursor: pointer;
        }
        .name-list-item.pending:hover {
            background: #e2e8f0;
            transform: translateX(3px);
            border-left-color: #94a3b8;
        }
        .name-list-item.incorrect {
            background: #fee2e2;
            border-left-color: #ef4444;
            color: #991b1b;
        }
        .name-list-item.pending {
            background: #f1f5f9;
            color: #64748b;
        }
        .name-list-item:hover {
            transform: translateX(5px);
        }
        .map-area {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            min-height: 1200px; /* Maximize map height */
            display: flex;
            flex-direction: column;
            overflow-y: auto; /* Allow scroll in Safari */
            -webkit-overflow-scrolling: touch;
        }
        .map-wrapper {
            position: relative;
            display: block;
            cursor: grab; /* Default grab cursor */
            width: 100%;
            max-height: none; /* Remove height restriction */
            min-height: 1100px; /* Ensure tall map box */
            overflow: auto; /* Auto scrollbars for better Mac compatibility */
            -webkit-overflow-scrolling: touch;
            touch-action: manipulation; /* Allow pinch-zoom and panning */
        }
        .map-wrapper:active {
            cursor: grabbing; /* Grabbing when mouse down */
        }
        .map-wrapper::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }
        .map-wrapper::-webkit-scrollbar-track {
            background: #f1f5f9;
        }
        .map-wrapper::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 6px;
        }
        .map-wrapper::-webkit-scrollbar-thumb:hover {
            background: #764ba2;
        }
        .map-wrapper.skis {
            cursor: grab;
        }
        .map-wrapper.skis:active {
            cursor: grabbing;
        }
        .map-wrapper.snowboard {
            cursor: grab;
        }
        .map-wrapper.snowboard:active {
            cursor: grabbing;
        }
        #mapCanvas {
            display: block;
            border: 2px solid #cbd5e1;
            border-radius: 8px;
            min-width: 100%; /* Ensure canvas can expand beyond container */
            min-height: 100%;
        }
        .instruction {
            background: #fef3c7;
            border-left: 4px solid #f59e0b;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 1.1em;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        .sidebar .controls {
            margin-bottom: 12px;
            flex-direction: column;
        }
        .map-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
            text-align: center;
        }
        .sidebar .btn {
            width: 100%;
        }
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .btn-success {
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
            color: white;
        }
        .btn-secondary {
            background: #94a3b8;
            color: white;
        }
        .btn-secondary.active {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            box-shadow: 0 0 15px rgba(34, 197, 94, 0.5);
        }
        .btn-danger {
            background: #ef4444;
            color: white;
        }
        .btn-warning {
            background: #f59e0b;
            color: white;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        .marker {
            position: absolute;
            width: 16px;
            height: 16px;
            background: #ef4444;
            border: 3px solid white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        .marker.correct {
            background: #22c55e;
        }
        .marker.incorrect {
            background: #ef4444;
        }
        .marker-label {
            position: absolute;
            background: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
            color: #334155;
            white-space: nowrap;
            pointer-events: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            border: 1px solid #cbd5e1;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-bottom: 12px;
            flex-shrink: 0;
        }
        .stat-box {
            background: #f8fafc;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid #e2e8f0;
        }
        .stat-value {
            font-size: 1.6em;
            font-weight: bold;
            color: #667eea;
        }
        .stat-value.correct {
            color: #22c55e;
        }
        .stat-value.incorrect {
            color: #ef4444;
        }
        .stat-label {
            font-size: 0.9em;
            color: #64748b;
            margin-top: 5px;
        }
        .result-message {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-weight: 600;
            text-align: center;
            display: none;
        }
        .result-message.show {
            display: block;
        }
        .result-message.perfect {
            background: #d1fae5;
            color: #065f46;
            border: 2px solid #22c55e;
        }
        .result-message.good {
            background: #dbeafe;
            color: #1e40af;
            border: 2px solid #3b82f6;
        }
        .result-message.try-again {
            background: #fee2e2;
            color: #991b1b;
            border: 2px solid #ef4444;
        }
        .feedback-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 30px 50px;
            border-radius: 15px;
            font-size: 2em;
            font-weight: bold;
            z-index: 1000;
            animation: popupFade 1s ease;
            pointer-events: none;
        }
        .feedback-popup.correct {
            background: #22c55e;
            color: white;
        }
        .feedback-popup.incorrect {
            background: #ef4444;
            color: white;
        }
        @keyframes popupFade {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            30% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            70% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }
        
        /* Mobile & Tablet Responsive Styles */
        @media screen and (max-width: 1024px) {
            body {
                padding: 10px;
            }
            
            .main-content {
                grid-template-columns: 1fr;
                height: auto;
                gap: 15px;
            }
            
            .sidebar {
                height: auto;
                max-height: none;
                min-height: 500px;
                order: 2;
            }
            
            .name-list-container {
                min-height: 250px;
            }
            
            .map-area {
                order: 1;
                height: auto;
            }
            
            .mode-selector {
                flex-direction: column;
                gap: 10px;
            }
            
            .mode-btn {
                padding: 12px;
                font-size: 0.95em;
            }
            
            /* Tablet button layout - 3 columns */
            .map-area .controls {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 10px;
            }
            
            .btn {
                padding: 12px 14px;
                font-size: 0.88em;
                min-height: 48px;
            }
            
            /* Sidebar buttons stay full width */
            .sidebar .controls {
                display: flex;
                flex-direction: column;
                gap: 10px;
            }
            
            .sidebar .btn {
                width: 100%;
                padding: 14px 16px;
                font-size: 0.95em;
            }
            
            .header h1 {
                font-size: 1.5em;
            }
            
            .stats {
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }
            
            .stat-value {
                font-size: 1.8em;
            }
            
            .current-name {
                padding: 15px;
            }
            
            .current-name .name {
                font-size: 1.5em;
            }
            
            .instruction {
                font-size: 0.95em;
                padding: 12px;
            }
            
            .feedback-popup {
                font-size: 1.5em;
                padding: 20px 35px;
            }
            
            /* Better touch targets for mobile */
            .name-item {
                min-height: 50px;
                padding: 12px;
                font-size: 1em;
            }
            
            .location-toggle label {
                padding: 10px 15px;
                font-size: 0.95em;
            }
        }
        
        /* Phone-specific styles */
        @media screen and (max-width: 600px) {
            body {
                padding: 5px;
            }
            
            .header {
                padding: 15px;
            }
            
            .header h1 {
                font-size: 1.2em;
                margin-bottom: 8px;
            }
            
            .sidebar {
                max-height: none;
                min-height: 400px;
                padding: 12px;
            }
            
            .sidebar h2 {
                font-size: 1em;
            }
            
            .name-list-container {
                min-height: 200px;
                max-height: none; /* Remove desktop scrollable constraint */
            }
            
            /* Reset map area to mobile-friendly sizes */
            .map-area {
                min-height: 400px !important;
            }
            
            .map-wrapper {
                min-height: 300px !important;
                max-height: none !important; /* Allow pinch zoom to expand */
                touch-action: manipulation !important; /* Ensure pinch-zoom works */
            }
            
            /* Sidebar buttons - full width, larger */
            .sidebar .controls {
                gap: 10px;
            }
            
            .sidebar .btn {
                padding: 14px 16px;
                font-size: 0.95em;
                min-height: 50px;
            }
            
            /* Map area controls - organized in rows */
            .map-area .controls {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 8px;
                justify-content: stretch;
            }
            
            .map-area .btn {
                padding: 12px 10px;
                font-size: 0.8em;
                min-height: 48px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            
            .stats {
                gap: 6px;
            }
            
            .stat-box {
                padding: 8px;
            }
            
            .stat-value {
                font-size: 1.4em;
            }
            
            .stat-label {
                font-size: 0.8em;
            }
            
            .current-name {
                padding: 12px;
            }
            
            .current-name .label {
                font-size: 0.9em;
            }
            
            .current-name .name {
                font-size: 1.3em;
            }
            
            .instruction {
                font-size: 0.85em;
                padding: 10px;
            }
            
            .progress-fill {
                font-size: 0.85em;
            }
            
            .name-item {
                min-height: 48px;
                padding: 10px;
                font-size: 0.95em;
            }
            
            .feedback-popup {
                font-size: 1.2em;
                padding: 15px 25px;
            }
            
            /* Make buttons easier to tap */
            button, .btn {
                min-height: 44px;
            }
            
            /* Adjust mode selector for smaller screens */
            .mode-btn {
                padding: 10px;
                font-size: 0.9em;
            }
            
            /* Compact layout adjustments */
            .main-content {
                gap: 10px;
            }
        }
        
        /* Landscape mobile orientation */
        @media screen and (max-height: 500px) and (orientation: landscape) {
            .header {
                padding: 10px;
                margin-bottom: 10px;
            }
            
            .header h1 {
                font-size: 1.1em;
                margin-bottom: 5px;
            }
            
            .mode-selector {
                flex-direction: row;
            }
            
            .sidebar {
                max-height: none;
                min-height: 300px;
            }
            
            .name-list-container {
                min-height: 150px;
            }
            
            .progress-bar {
                height: 20px;
                margin-top: 8px;
            }
            
            /* Increase map visibility in landscape */
            .map-wrapper {
                max-height: calc(100vh - 200px);
                min-height: 400px;
            }
        }
        
        /* Touch device optimizations */
        @media (hover: none) and (pointer: coarse) {
            /* Better touch targets */
            button, .btn, .name-item {
                min-height: 44px;
            }
            
            /* Prevent double-tap zoom */
            * {
                touch-action: manipulation;
            }
            
            /* Remove hover effects on touch devices */
            .btn:hover,
            .mode-btn:hover:not(.active),
            .name-item:hover {
                transform: none;
            }
            
            /* Add active/pressed state instead */
            .btn:active {
                transform: scale(0.95);
            }
            
            .name-item:active {
                background: #e0e7ff;
            }
        }
        
        /* Safari-specific fixes */
        @supports (-webkit-appearance: none) {
            .main-content {
                height: auto !important;
                max-height: none !important;
                min-height: 1200px !important;
            }
            
            .sidebar, .map-area {
                height: auto !important;
                max-height: none !important;
                min-height: 1000px !important;
            }
            
            .name-list-container {
                max-height: none !important;
                min-height: 800px !important;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>⛷️ Bogus Basin Interactive Map</h1>
            <p>Learn the locations of all lifts and runs at Bogus Basin!</p>
        </div>

        <div id="practiceMode">
            <div class="main-content">
                <div class="sidebar">
                    <div class="current-name" id="currentNameBox">
                        <div class="label">Find this location:</div>
                        <div class="name" id="currentName">Alpine</div>
                    </div>

                    <div class="stats">
                        <div class="stat-box">
                            <div class="stat-value" id="completedCount">0</div>
                            <div class="stat-label">Completed</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="remainingCount">120</div>
                            <div class="stat-label">Remaining</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="percentComplete">0%</div>
                            <div class="stat-label">Progress</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="streakCount">0</div>
                            <div class="stat-label">Streak 🔥</div>
                        </div>
                    </div>

                    <div class="controls" style="flex-direction: column; gap: 8px; flex-shrink: 0;">
                        <button class="btn btn-secondary" onclick="skipCurrent()" title="Skip this location and move to the next one">⏭️ Skip</button>
                        <button class="btn btn-secondary" onclick="scrambleList()" title="Shuffle the order of locations in the list below">🔀 Scramble List</button>
                        <button class="btn btn-secondary" onclick="toggleMapText()" id="hideMapTextBtn" title="Hide trail and lift names printed on the map">🙈 Hide Map Text</button>
                        <button class="btn btn-danger" onclick="resetPractice()" title="Start over from the beginning with a fresh session">🔄 Reset</button>
                    </div>

                    <h2>Location List <span style="font-size: 0.7em; color: #64748b; font-weight: normal;">(click any to select)</span></h2>
                    
                    <!-- Search box -->
                    <div style="margin-bottom: 10px; position: relative;">
                        <input type="text" id="locationSearch" placeholder="🔍 Search lifts, runs, lodges..." 
                               style="width: 100%; padding: 8px 30px 8px 12px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 14px; background: #f8fafc;" 
                               oninput="filterLocations()" onkeydown="handleSearchKeydown(event)" />
                        <button onclick="clearSearch()" id="clearSearchBtn" 
                                style="position: absolute; right: 5px; top: 50%; transform: translateY(-50%); background: none; border: none; cursor: pointer; font-size: 16px; color: #64748b; display: none;"
                                title="Clear search">✕</button>
                        <div id="searchResults" style="font-size: 12px; color: #64748b; margin-top: 4px;"></div>
                    </div>
                    
                    <div class="name-list-container">
                        <div id="namesList"></div>
                    </div>
                </div>

                <div class="map-area">
                    <div class="instruction">
                        👆 <strong>Click on the map</strong> where "<span id="instructionName">Alpine</span>" is located
                        <br><small style="opacity: 0.8;">💡 Tip: Turn on Auto-Zoom, then click any location in the list to jump right to it!</small>
                    </div>

                    <div class="controls map-controls">
                        <button class="btn btn-secondary" onclick="toggleAutoZoom()" id="autoZoomBtn" title="Automatically zoom to the current location when selected">� Auto-Zoom: OFF</button>
                        <button class="btn btn-secondary" onclick="toggleLabels()" id="labelsBtn" title="Show or hide location labels on the map">�️ Labels</button>
                        <button class="btn btn-secondary" onclick="zoomIn()" title="Zoom in on the map (up to 1000%)">🔍+ Zoom In</button>
                        <button class="btn btn-secondary" onclick="zoomOut()" title="Zoom out on the map">🔍- Zoom Out</button>
                        <button class="btn btn-secondary" onclick="resetZoom()" title="Reset zoom level back to 100%">↺ Reset Map</button>
                        <button class="btn btn-secondary" onclick="window.open('https://github.com/MountainsToGo/bbm/blob/main/USER_GUIDE.md', '_blank')" title="Open user guide in a new tab">📖 User Guide</button>
                    </div>
                    
                    <div style="background: #f0f9ff; padding: 10px; border-radius: 6px; margin-bottom: 10px;">
                        <strong>Zoom Level:</strong> <span id="zoomLevel">100%</span> | 
                        <strong>Auto-Zoom:</strong> <span id="autoZoomStatus">OFF</span> | 
                        <strong>Tip:</strong> Use Ctrl+Scroll to zoom
                    </div>

                    <div class="map-wrapper" id="practiceMapWrapper">
                        <canvas id="mapCanvas"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="location_names.js"></script>
    <script>
        let currentMode = 'practice';
        let currentIndex = 0;
        let locations = [];
        let displayOrder = []; // Array of indices to control list display order (can be shuffled)
        let showLabels = false;
        let canvasScale = 1;
        let zoomLevel = 1.0;
        let correctCount = 0;
        let incorrectCount = 0;
        let streak = 0;
        let clickMarkers = []; // Store click markers for visual feedback
        let completedIndices = new Set(); // Track which locations were actually completed (not skipped)
        let skippedIndices = new Set(); // Track which locations were skipped
        let autoZoomEnabled = false; // Toggle for auto-zoom to selected location
        let highlightTimer = null; // Timer for temporary highlight
        let highlightedLocationIndex = null; // Track which location to highlight (for viewing completed items)
        let hideMapText = false; // Toggle to hide trail/lift names on the map image
        let textOverlays = []; // Array of overlay rectangles loaded from text_overlays.json
        let revealedOverlays = new Set(); // Track which overlays have been revealed by correct answers
        
        // Celebration animation variables
        let celebrationActive = false;
        let celebrationStartTime = null;
        let skierTrail = [];
        let snowboarderTrail = [];
        let snowflakes = []; // Array of snowflakes for celebration

        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');
        const img = new Image();

        // Load image first
        img.onload = function() {
            // Use full image size - let CSS scale it down
            canvasScale = 1;
            
            canvas.width = img.width;  // 3131px
            canvas.height = img.height; // 1999px
            
            // Scale canvas to fit container using CSS transform
            canvas.style.width = '100%';
            canvas.style.height = 'auto';
            
            // Then load configuration with cache-busting
            const VERSION = '120locations'; // Update this to force cache refresh
            const cacheBuster = new Date().getTime();
            fetch(`bogus_basin_config.json?v=${VERSION}_${cacheBuster}`, {
                cache: 'no-cache',
                headers: {
                    'Cache-Control': 'no-cache, no-store, must-revalidate',
                    'Pragma': 'no-cache',
                    'Expires': '0'
                }
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Could not load JSON file');
                    }
                    return response.json();
                })
                .then(config => {
                    locations = config.locations;
                    console.log('RAW CONFIG LOADED - Total locations in JSON:', config.locations.length);
                    console.log('Locations array assigned:', locations.length);
                    if (locations.length === 0) {
                        alert('No locations found in configuration file!');
                        return;
                    }
                    
                    // Load text overlays configuration
                    return fetch('text_overlays.json?v=' + cacheBuster, {
                        cache: 'no-cache',
                        headers: {
                            'Cache-Control': 'no-cache, no-store, must-revalidate',
                            'Pragma': 'no-cache',
                            'Expires': '0'
                        }
                    });
                })
                .then(response => {
                    if (!response.ok) {
                        console.warn('No text overlays file found, continuing without overlays');
                        textOverlays = [];
                        initializeMode();
                        return null;
                    }
                    return response.json();
                })
                .then(overlayConfig => {
                    if (overlayConfig) {
                        textOverlays = overlayConfig.overlays || [];
                        console.log('Loaded', textOverlays.length, 'text overlays');
                    }
                    initializeMode();
                })
                .catch(err => {
                    console.error('Error loading config:', err);
                    
                    // Show helpful error message
                    const errorDiv = document.createElement('div');
                    errorDiv.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 15px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); max-width: 600px; z-index: 10000;';
                    errorDiv.innerHTML = `
                        <h2 style="color: #ef4444; margin-top: 0;">⚠️ Cannot Load Configuration</h2>
                        <p><strong>This app needs to run from a web server, not by opening the file directly.</strong></p>
                        <h3>Quick Fix - Option 1 (Python):</h3>
                        <ol>
                            <li>Open PowerShell in this folder</li>
                            <li>Run: <code style="background: #f1f5f9; padding: 4px 8px; border-radius: 4px;">python -m http.server 8000</code></li>
                            <li>Open browser to: <a href="http://localhost:8000/learn.html" target="_blank">http://localhost:8000/learn.html</a></li>
                        </ol>
                        <h3>Quick Fix - Option 2 (VS Code):</h3>
                        <ol>
                            <li>Install "Live Server" extension in VS Code</li>
                            <li>Right-click learn.html and select "Open with Live Server"</li>
                        </ol>
                        <button onclick="this.parentElement.remove()" style="padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; margin-top: 15px;">Close</button>
                    `;
                    document.body.appendChild(errorDiv);
                });
        };
        img.src = 'trail_map.png';

        function initializeMode() {
            currentIndex = 0;
            correctCount = 0;
            incorrectCount = 0;
            streak = 0;
            clickMarkers = [];
            completedIndices = new Set();
            skippedIndices = new Set();
            revealedOverlays = new Set(); // Reset revealed overlays on restart
            celebrationActive = false; // Stop celebration animation
            celebrationStartTime = null;
            skierTrail = [];
            snowboarderTrail = [];
            snowflakes = []; // Clear snowflakes
            
            if (locations.length === 0) {
                console.error('No locations loaded!');
                return;
            }
            
            // Keep locations in alphabetical order
            console.log('BEFORE SORT:', locations.length, 'locations');
            locations = [...locations].sort((a, b) => a.name.localeCompare(b.name));
            console.log('AFTER SORT:', locations.length, 'locations');
            
            // Initialize display order as sequential (0, 1, 2, ...)
            displayOrder = locations.map((_, index) => index);
            
            console.log('Initialized with', locations.length, 'locations');
            console.log('First location:', locations[0]);
            
            updateUI();
            drawMap();
        }

        function drawMap() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            
            // Draw black overlays to hide trail/lift text on map if enabled
            if (hideMapText && textOverlays.length > 0) {
                ctx.fillStyle = 'rgba(0, 0, 0, 1.0)';
                textOverlays.forEach((overlay, index) => {
                    // Skip overlays that have been revealed by correct answers
                    if (revealedOverlays.has(index)) {
                        return;
                    }
                    
                    ctx.save();
                    
                    // Apply rotation if specified
                    if (overlay.rotation) {
                        const centerX = (overlay.x + overlay.width / 2) * canvasScale;
                        const centerY = (overlay.y + overlay.height / 2) * canvasScale;
                        ctx.translate(centerX, centerY);
                        ctx.rotate((overlay.rotation * Math.PI) / 180);
                        ctx.translate(-centerX, -centerY);
                    }
                    
                    ctx.fillRect(
                        overlay.x * canvasScale,
                        overlay.y * canvasScale,
                        overlay.width * canvasScale,
                        overlay.height * canvasScale
                    );
                    
                    ctx.restore();
                });
            }
            
            // Draw white boxes at all location coordinates
            locations.forEach((loc, index) => {
                // Draw white boxes for pending and skipped locations (not completed)
                if (!completedIndices.has(index)) {
                    const boxSize = 16;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.strokeStyle = '#ef4444';
                    ctx.lineWidth = 3;
                    ctx.fillRect(
                        loc.x * canvasScale - boxSize/2,
                        loc.y * canvasScale - boxSize/2,
                        boxSize,
                        boxSize
                    );
                    ctx.strokeRect(
                        loc.x * canvasScale - boxSize/2,
                        loc.y * canvasScale - boxSize/2,
                        boxSize,
                        boxSize
                    );
                }
            });
            
            // Draw click markers (X marks for correct/incorrect)
            clickMarkers.forEach(marker => {
                const size = 20;
                ctx.strokeStyle = marker.correct ? '#22c55e' : '#ef4444';
                ctx.lineWidth = 4;
                
                // Draw X
                ctx.beginPath();
                ctx.moveTo(marker.x - size/2, marker.y - size/2);
                ctx.lineTo(marker.x + size/2, marker.y + size/2);
                ctx.moveTo(marker.x + size/2, marker.y - size/2);
                ctx.lineTo(marker.x - size/2, marker.y + size/2);
                ctx.stroke();
                
                // Draw circle around it
                ctx.beginPath();
                ctx.arc(marker.x, marker.y, size, 0, 2 * Math.PI);
                ctx.stroke();
            });
            
            // Draw completed locations as green dots (only truly completed, not skipped)
            completedIndices.forEach(i => {
                const loc = locations[i];
                ctx.fillStyle = '#22c55e';
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(loc.x * canvasScale, loc.y * canvasScale, 8, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();

                if (showLabels) {
                    ctx.fillStyle = 'white';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 3;
                    ctx.font = 'bold 18px Arial';
                    const text = loc.name;
                    ctx.strokeText(text, loc.x * canvasScale + 12, loc.y * canvasScale + 4);
                    ctx.fillText(text, loc.x * canvasScale + 12, loc.y * canvasScale + 4);
                }
            });
            
            // Draw red highlight circle for current location if auto-zoom is enabled
            // OR for any highlighted location (including completed ones that were clicked)
            if (autoZoomEnabled) {
                const highlightIndex = highlightedLocationIndex !== null ? highlightedLocationIndex : currentIndex;
                if (highlightIndex < locations.length) {
                    const loc = locations[highlightIndex];
                    ctx.save();
                    
                    // Bold, bright red circles - tighter around location
                    ctx.strokeStyle = '#dc2626'; // Darker, bolder red
                    ctx.lineWidth = 6; // Thicker lines
                    ctx.setLineDash([8, 4]); // Shorter dashes for bolder look
                    
                    // Draw three tighter concentric circles for emphasis
                    for (let i = 1; i <= 3; i++) {
                        ctx.beginPath();
                        // Tighter circles: 20px base + 8px increments (was 30px + 15px increments)
                        ctx.arc(loc.x * canvasScale, loc.y * canvasScale, 20 + (i * 8), 0, 2 * Math.PI);
                        ctx.globalAlpha = 0.9 - (i * 0.15); // Higher opacity for bolder look
                        ctx.stroke();
                    }
                    
                    // Add a solid inner circle for maximum visibility
                    ctx.setLineDash([]); // Solid line
                    ctx.lineWidth = 4;
                    ctx.globalAlpha = 1.0;
                    ctx.beginPath();
                    ctx.arc(loc.x * canvasScale, loc.y * canvasScale, 15, 0, 2 * Math.PI);
                    ctx.stroke();
                    
                    ctx.restore();
                }
            }
            
            // Check if all locations completed - trigger celebration animation
            if (completedIndices.size === locations.length && !celebrationActive) {
                celebrationActive = true;
                celebrationStartTime = Date.now();
                // Initialize snowflakes
                initSnowflakes();
                requestAnimationFrame(animateCelebration);
            }
        }
        
        function initSnowflakes() {
            // Create 80 snowflakes with random positions
            snowflakes = [];
            for (let i = 0; i < 80; i++) {
                snowflakes.push({
                    x: Math.random() * img.width,
                    y: Math.random() * img.height,
                    speed: 1 + Math.random() * 2, // Fall speed
                    drift: (Math.random() - 0.5) * 0.5, // Horizontal drift
                    size: 3 + Math.random() * 4 // Size variation
                });
            }
        }
        
        function animateCelebration() {
            if (!celebrationActive) return;
            
            const elapsed = Date.now() - celebrationStartTime;
            const duration = 10000; // 10 seconds for smoother animation
            const progress = Math.min(elapsed / duration, 1);
            
            // Linear progress for most of the run, then speed up at the end
            let easedProgress;
            if (progress < 0.7) {
                // First 70% - constant speed
                easedProgress = progress;
            } else {
                // Last 30% - accelerate
                const endProgress = (progress - 0.7) / 0.3;
                easedProgress = 0.7 + (0.3 * endProgress * endProgress);
            }
            
            // Calculate Y position (top to bottom of map)
            const startY = 0;
            const endY = img.height;
            const currentY = startY + (endY - startY) * easedProgress;
            
            // Zigzag motion for realistic skiing
            const zigzagAmount = 100; // pixels
            const zigzagFrequency = 12; // More oscillations per descent (was 8)
            const zigzag = Math.sin(progress * Math.PI * zigzagFrequency) * zigzagAmount;
            
            // Multiple skiers/snowboarders with completely different diagonal paths - mixed up!
            const routes = [
                // Route 1: Snowboarder - far left to center-right (starts immediately)
                {
                    startX: img.width * 0.05,
                    endX: img.width * 0.65,
                    zigzag: zigzag * 1.2,
                    emoji: '🏂',
                    name: 'snowboarder1',
                    delay: 0,      // No delay
                    duration: 1.0  // Normal speed
                },
                // Route 2: Skier - center to far left (starts 20% into animation)
                {
                    startX: img.width * 0.5,
                    endX: img.width * 0.1,
                    zigzag: -zigzag * 0.6,
                    emoji: '⛷️',
                    name: 'skier1',
                    delay: 0.2,    // Starts at 20% progress
                    duration: 0.8  // Faster
                },
                // Route 3: Snowboarder - right to center (starts 40% into animation)
                {
                    startX: img.width * 0.88,
                    endX: img.width * 0.45,
                    zigzag: -zigzag * 0.85,
                    emoji: '🏂',
                    name: 'snowboarder2',
                    delay: 0.4,    // Starts at 40% progress
                    duration: 0.9  // Slightly faster
                },
                // Route 4: Skier - center-left to far right (starts 15% into animation)
                {
                    startX: img.width * 0.3,
                    endX: img.width * 0.9,
                    zigzag: zigzag * 0.75,
                    emoji: '⛷️',
                    name: 'skier2',
                    delay: 0.15,   // Starts at 15% progress
                    duration: 1.1  // Slightly slower
                },
                // Route 5: Skier - far right to center-left (starts 30% into animation)
                {
                    startX: img.width * 0.95,
                    endX: img.width * 0.35,
                    zigzag: -zigzag * 1.1,
                    emoji: '⛷️',
                    name: 'skier3',
                    delay: 0.3,    // Starts at 30% progress
                    duration: 0.85 // Faster
                },
                // Route 6: Snowboarder - center-left to right (starts 10% into animation)
                {
                    startX: img.width * 0.25,
                    endX: img.width * 0.8,
                    zigzag: zigzag * 0.9,
                    emoji: '🏂',
                    name: 'snowboarder3',
                    delay: 0.1,    // Starts at 10% progress
                    duration: 1.05 // Slightly slower
                }
            ];
            
            // Store positions for each route with diagonal movement and timing
            const positions = [];
            routes.forEach(route => {
                // Calculate individual progress for this route based on delay and duration
                const routeProgress = (progress - route.delay) / route.duration;
                
                // Only show if route has started and not finished
                if (routeProgress >= 0 && routeProgress <= 1) {
                    // Use same easing for each route
                    let routeEasedProgress;
                    if (routeProgress < 0.7) {
                        routeEasedProgress = routeProgress;
                    } else {
                        const endProgress = (routeProgress - 0.7) / 0.3;
                        routeEasedProgress = 0.7 + (0.3 * endProgress * endProgress);
                    }
                    
                    const routeY = startY + (endY - startY) * routeEasedProgress;
                    const baseX = route.startX + (route.endX - route.startX) * routeEasedProgress;
                    
                    positions.push({
                        x: baseX + route.zigzag,
                        y: routeY,
                        emoji: route.emoji,
                        zigzag: route.zigzag
                    });
                }
            });
            
            // Add to trails (keeping for potential future use)
            skierTrail.push(positions[0]);
            snowboarderTrail.push(positions[1]);
            const trailLength = 15;
            if (skierTrail.length > trailLength) skierTrail.shift();
            if (snowboarderTrail.length > trailLength) snowboarderTrail.shift();
            
            // Redraw map with animation
            drawMap();
            
            // Save context for crisp rendering
            ctx.save();
            // ctx.imageSmoothingEnabled = false; // COMMENTED OUT - was causing blurriness with motion
            
            // Draw current position only (no trail to avoid blur)
            const emojiSize = 80; // Much bigger emojis
            ctx.font = `${emojiSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.globalAlpha = 1.0;
            
            // Draw each position with flipping based on zigzag direction
            positions.forEach(pos => {
                ctx.save();
                
                // Flip horizontally if moving left (negative zigzag)
                if (pos.zigzag < 0) {
                    // Translate to position, flip, then draw
                    ctx.translate(pos.x * canvasScale, pos.y * canvasScale);
                    ctx.scale(-1, 1); // Flip horizontally
                    ctx.fillText(pos.emoji, 0, 0);
                } else {
                    // Draw normally (facing right)
                    ctx.fillText(pos.emoji, pos.x * canvasScale, pos.y * canvasScale);
                }
                
                ctx.restore();
            });
            
            // Update and draw snowflakes
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            snowflakes.forEach(flake => {
                // Update position
                flake.y += flake.speed;
                flake.x += flake.drift;
                
                // Reset to top if fallen off bottom
                if (flake.y > img.height) {
                    flake.y = 0;
                    flake.x = Math.random() * img.width;
                }
                
                // Wrap around horizontally
                if (flake.x < 0) flake.x = img.width;
                if (flake.x > img.width) flake.x = 0;
                
                // Draw snowflake
                ctx.beginPath();
                ctx.arc(flake.x * canvasScale, flake.y * canvasScale, flake.size, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            ctx.restore();
            
            // Continue animation or restart immediately
            if (progress < 1) {
                requestAnimationFrame(animateCelebration);
            } else {
                // Loop the animation - restart immediately without pause
                if (completedIndices.size === locations.length) {
                    celebrationStartTime = Date.now();
                    skierTrail = [];
                    snowboarderTrail = [];
                    // Keep snowflakes falling, don't reset them
                    requestAnimationFrame(animateCelebration);
                }
            }
        }
        
        // Hidden keyboard shortcut to complete all locations (for testing)
        // Press Ctrl+Shift+Q to trigger
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey && e.shiftKey && e.key === 'Q') {
                e.preventDefault(); // Prevent any default browser behavior
                completeAll();
            }
        });

        canvas.addEventListener('click', function(e) {
            if (currentMode !== 'practice' || currentIndex >= locations.length) return;
            
            // Don't register clicks if user just finished dragging
            if (hasDragged) {
                hasDragged = false; // Reset for next interaction
                return;
            }

            const rect = canvas.getBoundingClientRect();
            // Convert click coordinates to canvas coordinates
            // Scale from screen pixels to canvas pixels
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const clickX = (e.clientX - rect.left) * scaleX;
            const clickY = (e.clientY - rect.top) * scaleY;

            const tolerance = 80; // Increased tolerance for easier clicking
            
            // Check if clicking on an already completed location (ignore it)
            for (const i of completedIndices) {
                const completedLoc = locations[i];
                const distToCompleted = Math.sqrt(Math.pow(clickX - completedLoc.x, 2) + Math.pow(clickY - completedLoc.y, 2));
                if (distToCompleted < tolerance) {
                    console.log('Ignoring click on already completed location:', completedLoc.name);
                    return; // Don't process clicks on completed locations
                }
            }

            const correctLoc = locations[currentIndex];
            const distance = Math.sqrt(Math.pow(clickX - correctLoc.x, 2) + Math.pow(clickY - correctLoc.y, 2));
            
            console.log('Click at:', clickX, clickY, 'Target:', correctLoc.x, correctLoc.y, 'Distance:', distance, 'Scale:', canvasScale, 'Zoom:', zoomLevel);
            console.log('📍 OVERLAY HELPER: {x: ' + Math.round(clickX) + ', y: ' + Math.round(clickY) + ', width: 200, height: 30},');

            const isCorrect = distance < tolerance;

            if (isCorrect) {
                showFeedback(true);
                correctCount++;
                streak++;
                
                // Mark this index as completed (not skipped)
                completedIndices.add(currentIndex);
                
                // Reveal ALL overlays for this location (some locations have multiple overlays)
                const currentLocationName = locations[currentIndex].name;
                textOverlays.forEach((overlay, index) => {
                    if (overlay.note === currentLocationName) {
                        revealedOverlays.add(index);
                    }
                });
                
                // Add ONE permanent green marker at the correct location
                clickMarkers.push({
                    x: correctLoc.x,
                    y: correctLoc.y,
                    correct: true,
                    permanent: true
                });
                
                // Move to next location in displayOrder (not alphabetically)
                moveToNextLocation();
            } else {
                showFeedback(false);
                incorrectCount++;
                streak = 0;
                
                // Add red marker temporarily
                clickMarkers.push({
                    x: clickX,
                    y: clickY,
                    correct: false
                });
                
                // Remove the incorrect marker after showing feedback
                setTimeout(() => {
                    clickMarkers = clickMarkers.filter(m => m.correct);
                    drawMap();
                }, 1000);
            }
            
            updateUI();
            drawMap();
        });

        // Mouse panning functionality
        let isPanning = false;
        let hasDragged = false; // Track if user actually dragged
        let panStartX = 0;
        let panStartY = 0;
        let scrollStartX = 0;
        let scrollStartY = 0;
        const MIN_DRAG_DISTANCE = 5; // Minimum pixels to consider it a drag vs click

        const mapWrapper = document.getElementById('practiceMapWrapper'); // Used for both panning and touch

        mapWrapper.addEventListener('mousedown', function(e) {
            // Only pan with left mouse button
            if (e.button !== 0) return;
            
            isPanning = true;
            hasDragged = false; // Reset drag flag
            panStartX = e.clientX;
            panStartY = e.clientY;
            scrollStartX = mapWrapper.scrollLeft;
            scrollStartY = mapWrapper.scrollTop;
            
            // Don't prevent default immediately - let Mac trackpad scroll work
            // Only prevent when actual dragging starts
        });

        mapWrapper.addEventListener('mousemove', function(e) {
            if (!isPanning) return;
            
            const deltaX = panStartX - e.clientX;
            const deltaY = panStartY - e.clientY;
            
            // Check if user has moved enough to be considered a drag
            const dragDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            if (dragDistance > MIN_DRAG_DISTANCE) {
                hasDragged = true;
                mapWrapper.style.cursor = 'grabbing';
            }
            
            // Only do manual scrolling if actually dragging (not just clicked)
            if (hasDragged) {
                mapWrapper.scrollLeft = scrollStartX + deltaX;
                mapWrapper.scrollTop = scrollStartY + deltaY;
            }
        });

        mapWrapper.addEventListener('mouseup', function(e) {
            if (isPanning) {
                isPanning = false;
                // Reset cursor - changeCursor will set the right one
                updateMapCursor();
            }
        });

        mapWrapper.addEventListener('mouseleave', function() {
            if (isPanning) {
                isPanning = false;
                updateMapCursor();
            }
        });
        
        // Helper function to update cursor based on current selection
        function updateMapCursor() {
            if (currentCursorType === 'skis' || currentCursorType === 'snowboard') {
                // Keep the class-based cursor
                mapWrapper.style.cursor = '';
            } else {
                mapWrapper.style.cursor = 'grab';
            }
        }

        function showFeedback(correct) {
            const popup = document.createElement('div');
            popup.className = `feedback-popup ${correct ? 'correct' : 'incorrect'}`;
            popup.textContent = correct ? '✓ Correct!' : '✗ Try Again';
            document.body.appendChild(popup);
            setTimeout(() => popup.remove(), 1000);
        }

        function updateUI() {
            if (currentIndex < locations.length) {
                document.getElementById('currentName').textContent = locations[currentIndex].name;
                document.getElementById('instructionName').textContent = locations[currentIndex].name;
            } else {
                document.getElementById('currentName').textContent = '✓ Complete!';
                document.getElementById('instructionName').textContent = 'All locations learned';
                document.querySelector('.instruction').style.background = '#d1fae5';
                document.querySelector('.instruction').style.borderColor = '#10b981';
            }

            const completed = completedIndices.size;
            const remaining = locations.length - completed;
            const percent = Math.round((completed / locations.length) * 100);

            document.getElementById('completedCount').textContent = completed;
            document.getElementById('remainingCount').textContent = remaining;
            document.getElementById('percentComplete').textContent = percent + '%';
            document.getElementById('streakCount').textContent = streak;

            // Progress bar removed from UI
            // const progressBar = document.getElementById('progressBar');
            // progressBar.style.width = percent + '%';
            // progressBar.textContent = `${completed} / ${locations.length}`;

            updateList();
        }

        function updateList() {
            const list = document.getElementById('namesList');
            list.innerHTML = '';
            // Use displayOrder to control the order items appear in the list
            displayOrder.forEach(index => {
                const loc = locations[index];
                const item = document.createElement('div');
                item.className = 'name-list-item';
                
                if (completedIndices.has(index)) {
                    // Completed (correctly answered) - NOW CLICKABLE to zoom/view
                    item.classList.add('completed');
                    item.innerHTML = `✓ ${loc.name}`;
                    item.style.cursor = 'pointer';
                    item.onclick = function() {
                        // Allow clicking completed items to zoom to them
                        highlightedLocationIndex = index; // Set which location to highlight
                        if (autoZoomEnabled) {
                            zoomToLocation(index);
                        }
                        // Don't change currentIndex, just zoom to view
                        drawMap();
                    };
                } else if (skippedIndices.has(index)) {
                    // Skipped - clickable to jump back to it
                    item.classList.add('pending');
                    item.innerHTML = `⏭️ ${loc.name}`;
                    item.style.cursor = 'pointer';
                    item.onclick = function() {
                        highlightedLocationIndex = null; // Reset to use currentIndex
                        currentIndex = index;
                        skippedIndices.delete(index); // Remove from skipped when retrying
                        if (autoZoomEnabled) {
                            zoomToLocation(index);
                        }
                        updateUI();
                        drawMap();
                    };
                } else if (index === currentIndex) {
                    // Current - clickable to stay on it
                    item.classList.add('current');
                    item.innerHTML = `→ ${loc.name}`;
                    item.style.cursor = 'pointer';
                    item.onclick = function() {
                        // Allow re-selecting current item
                        highlightedLocationIndex = null; // Reset to use currentIndex
                        if (autoZoomEnabled) {
                            zoomToLocation(index);
                        }
                        updateUI();
                        drawMap();
                    };
                } else {
                    // Pending or not yet reached - make all clickable!
                    item.classList.add('pending');
                    item.innerHTML = loc.name;
                    item.style.cursor = 'pointer';
                    item.onclick = function() {
                        highlightedLocationIndex = null; // Reset to use currentIndex
                        currentIndex = index;
                        if (autoZoomEnabled) {
                            zoomToLocation(index);
                        }
                        updateUI();
                        drawMap();
                    };
                }
                
                list.appendChild(item);
            });
        }

        function showAnswer() {
            if (currentIndex >= locations.length) return;
            
            const loc = locations[currentIndex];
            
            // Draw the map first
            drawMap();
            
            // Draw a pulsing highlight on the correct location
            ctx.save();
            ctx.fillStyle = 'rgba(34, 197, 94, 0.5)';
            ctx.strokeStyle = '#22c55e';
            ctx.lineWidth = 4;
            
            // Draw large circle
            ctx.beginPath();
            ctx.arc(loc.x * canvasScale, loc.y * canvasScale, 40, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
            
            // Draw arrow pointing to location
            ctx.fillStyle = '#22c55e';
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.strokeText('↓', loc.x * canvasScale, loc.y * canvasScale - 50);
            ctx.fillText('↓', loc.x * canvasScale, loc.y * canvasScale - 50);
            
            // Draw label
            ctx.font = 'bold 16px Arial';
            ctx.fillStyle = 'white';
            ctx.strokeStyle = '#22c55e';
            ctx.lineWidth = 4;
            const text = loc.name + ' is here!';
            ctx.strokeText(text, loc.x * canvasScale, loc.y * canvasScale + 60);
            ctx.fillText(text, loc.x * canvasScale, loc.y * canvasScale + 60);
            
            ctx.restore();
            
            setTimeout(() => drawMap(), 3000);
        }

        // Helper function to move to the next incomplete location in displayOrder
        function moveToNextLocation() {
            // Find the current location's position in displayOrder
            const currentPosition = displayOrder.indexOf(currentIndex);
            
            // Start searching from the next position in displayOrder
            for (let i = currentPosition + 1; i < displayOrder.length; i++) {
                const locationIndex = displayOrder[i];
                // Find first location that isn't completed or skipped
                if (!completedIndices.has(locationIndex) && !skippedIndices.has(locationIndex)) {
                    currentIndex = locationIndex;
                    return;
                }
            }
            
            // If no incomplete locations found after current position, we've reached the end
            currentIndex = locations.length;
        }

        function skipCurrent() {
            if (currentIndex < locations.length) {
                skippedIndices.add(currentIndex);
                moveToNextLocation();
                streak = 0;
                updateUI();
                drawMap();
            }
        }

        function scrambleList() {
            // Fisher-Yates shuffle algorithm to randomize displayOrder
            const shuffled = [...displayOrder];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            displayOrder = shuffled;
            
            // After scrambling, jump to the first incomplete location in the new order
            for (let i = 0; i < displayOrder.length; i++) {
                const locationIndex = displayOrder[i];
                // Skip completed and skipped locations, find first pending location
                if (!completedIndices.has(locationIndex) && !skippedIndices.has(locationIndex)) {
                    currentIndex = locationIndex;
                    break;
                }
            }
            
            // Re-render the list with new order and update UI to show new current location
            updateUI();
            drawMap();
        }
        
        function completeAll() {
            // Mark all locations as completed for testing the celebration animation
            for (let i = 0; i < locations.length; i++) {
                completedIndices.add(i);
                // Reveal all overlays
                textOverlays.forEach((overlay, index) => {
                    revealedOverlays.add(index);
                });
            }
            currentIndex = locations.length; // Move past the last location
            updateUI();
            drawMap();
        }

        function toggleMapText() {
            hideMapText = !hideMapText;
            const btn = document.getElementById('hideMapTextBtn');
            
            if (hideMapText) {
                // Map text hidden
                btn.textContent = '👁️ Show Map Text';
                btn.classList.remove('btn-secondary');
                btn.classList.add('btn-primary');
            } else {
                // Map text visible
                btn.textContent = '🙈 Hide Map Text';
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-secondary');
            }
            
            drawMap();
        }

        function resetPractice() {
            if (confirm('Start over from the beginning?')) {
                initializeMode();
            }
        }
        
        function filterLocations() {
            const searchTerm = document.getElementById('locationSearch').value.toLowerCase();
            const searchResults = document.getElementById('searchResults');
            
            if (searchTerm === '') {
                // Show all locations when search is empty
                displayOrder = [...Array(locations.length).keys()];
                updateList();
                searchResults.textContent = '';
                return;
            }
            
            // Filter locations based on search term
            const matchingIndices = [];
            locations.forEach((location, index) => {
                if (location.name.toLowerCase().includes(searchTerm)) {
                    matchingIndices.push(index);
                }
            });
            
            // Update display order to show only matching locations
            displayOrder = matchingIndices;
            updateList();
            
            // Update search results info
            if (matchingIndices.length === 0) {
                searchResults.textContent = 'No locations found';
                searchResults.style.color = '#ef4444';
            } else if (matchingIndices.length === 1) {
                searchResults.textContent = '1 location found';
                searchResults.style.color = '#22c55e';
            } else {
                searchResults.textContent = `${matchingIndices.length} locations found`;
                searchResults.style.color = '#22c55e';
            }
            
            // Show/hide clear button
            const clearBtn = document.getElementById('clearSearchBtn');
            clearBtn.style.display = searchTerm ? 'block' : 'none';
        }
        
        function clearSearch() {
            document.getElementById('locationSearch').value = '';
            filterLocations(); // This will reset to show all locations
            document.getElementById('locationSearch').focus();
        }
        
        function handleSearchKeydown(event) {
            // Clear search on Escape key
            if (event.key === 'Escape') {
                clearSearch();
            }
            // Jump to first result on Enter key
            else if (event.key === 'Enter') {
                const firstVisible = displayOrder[0];
                if (firstVisible !== undefined && autoZoomEnabled) {
                    zoomToLocation(firstVisible);
                    drawMap();
                }
            }
        }

        function toggleLabels() {
            showLabels = !showLabels;
            const btn = document.getElementById('labelsBtn');
            
            if (showLabels) {
                // Labels ON - show green
                btn.classList.remove('btn-secondary');
                btn.classList.add('btn-primary');
            } else {
                // Labels OFF - show gray
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-secondary');
            }
            
            drawMap();
        }

        function zoomIn() {
            zoomLevel = Math.min(10.0, zoomLevel + 0.25);
            applyZoom();
        }

        function zoomOut() {
            zoomLevel = Math.max(1.0, zoomLevel - 0.25); // Minimum zoom is 100%
            applyZoom();
        }

        function resetZoom() {
            zoomLevel = 1.0;
            
            // Restore to EXACT initial state (same as page load)
            canvas.style.width = '100%';
            canvas.style.height = 'auto';
            canvas.style.maxWidth = '';
            canvas.style.maxHeight = '';
            canvas.style.minWidth = '';
            canvas.style.minHeight = '';
            canvas.style.transform = '';
            canvas.style.aspectRatio = '';
            
            // Reset scroll position to top-left
            mapWrapper.scrollLeft = 0;
            mapWrapper.scrollTop = 0;
            
            // Update display
            document.getElementById('zoomLevel').textContent = '100%';
            
            // Force redraw
            drawMap();
        }

        function applyZoom() {
            // Use percentage-based sizing (matching initial setup)
            canvas.style.width = (100 * zoomLevel) + '%';
            canvas.style.height = 'auto';
            canvas.style.transform = 'none';
            document.getElementById('zoomLevel').textContent = Math.round(zoomLevel * 100) + '%';
        }

        function toggleAutoZoom() {
            autoZoomEnabled = !autoZoomEnabled;
            const btn = document.getElementById('autoZoomBtn');
            const status = document.getElementById('autoZoomStatus');
            
            if (autoZoomEnabled) {
                btn.textContent = '🎯 Auto-Zoom: ON';
                btn.classList.add('active');
                status.textContent = 'ON';
                status.style.color = '#22c55e';
                status.style.fontWeight = 'bold';
                // Immediately zoom to current location
                zoomToLocation(currentIndex);
            } else {
                btn.textContent = '🎯 Auto-Zoom: OFF';
                btn.classList.remove('active');
                status.textContent = 'OFF';
                status.style.color = '#64748b';
                status.style.fontWeight = 'normal';
                // Reset to normal view
                zoomLevel = 1.0;
                applyZoom();
                const mapWrapper = document.getElementById('practiceMapWrapper');
                mapWrapper.scrollLeft = 0;
                mapWrapper.scrollTop = 0;
                drawMap();
            }
        }

        function zoomToLocation(index) {
            if (index >= locations.length) return;
            
            const loc = locations[index];
            const mapWrapper = document.getElementById('practiceMapWrapper');
            
            // Set zoom level to 1.5x (less aggressive)
            zoomLevel = 1.5;
            applyZoom();
            
            // Calculate scroll position to center the location
            // Account for both canvas scale and zoom level
            const scaledX = loc.x * canvasScale * zoomLevel;
            const scaledY = loc.y * canvasScale * zoomLevel;
            
            const scrollX = scaledX - (mapWrapper.clientWidth / 2);
            const scrollY = scaledY - (mapWrapper.clientHeight / 2);
            
            mapWrapper.scrollLeft = Math.max(0, scrollX);
            mapWrapper.scrollTop = Math.max(0, scrollY);
            
            // Redraw with highlight
            drawMap();
        }

        let currentCursorType = 'default'; // Track current cursor selection

        function changeCursor(type) {
            const mapWrapper = document.getElementById('practiceMapWrapper');
            currentCursorType = type;
            
            // Remove all cursor classes
            mapWrapper.classList.remove('skis', 'snowboard');
            
            // Remove active class from all cursor buttons
            document.querySelectorAll('[onclick^="changeCursor"]').forEach(btn => {
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-secondary');
            });
            
            // Add the selected cursor class (all use grab/grabbing now)
            if (type === 'skis') {
                mapWrapper.classList.add('skis');
                document.getElementById('cursorType').textContent = 'Skier ⛷️';
                // Highlight the ski button
                document.querySelector('[onclick="changeCursor(\'skis\')"]').classList.remove('btn-secondary');
                document.querySelector('[onclick="changeCursor(\'skis\')"]').classList.add('btn-primary');
            } else if (type === 'snowboard') {
                mapWrapper.classList.add('snowboard');
                document.getElementById('cursorType').textContent = 'Snowboarder 🏂';
                // Highlight the snowboard button
                document.querySelector('[onclick="changeCursor(\'snowboard\')"]').classList.remove('btn-secondary');
                document.querySelector('[onclick="changeCursor(\'snowboard\')"]').classList.add('btn-primary');
            } else {
                // Default to grab cursor (pointer finger style)
                document.getElementById('cursorType').textContent = 'Pointer 👆';
                // Highlight the default button
                document.querySelector('[onclick="changeCursor(\'default\')"]').classList.remove('btn-secondary');
                document.querySelector('[onclick="changeCursor(\'default\')"]').classList.add('btn-primary');
            }
            
            // Update the cursor
            updateMapCursor();
        }
        
        // Set default cursor on load
        changeCursor('default');

        canvas.addEventListener('wheel', function(e) {
            if (e.ctrlKey) {
                e.preventDefault();
                if (e.deltaY < 0) {
                    zoomIn();
                } else {
                    zoomOut();
                }
            }
        }, { passive: false });

        // Pinch-to-zoom for touch devices
        let initialPinchDistance = null;
        let initialZoomLevel = 1.0;

        canvas.addEventListener('touchstart', function(e) {
            if (e.touches.length === 2) {
                e.preventDefault();
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                initialPinchDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                initialZoomLevel = zoomLevel;
            }
        });

        canvas.addEventListener('touchmove', function(e) {
            if (e.touches.length === 2) {
                e.preventDefault();
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const currentDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                if (initialPinchDistance) {
                    const scale = currentDistance / initialPinchDistance;
                    const newZoom = initialZoomLevel * scale;
                    
                    // Clamp between 1.0x (100%) and 10x (1000%)
                    zoomLevel = Math.max(1.0, Math.min(10.0, newZoom));
                    
                    document.getElementById('zoomLevel').textContent = Math.round(zoomLevel * 100) + '%';
                    applyZoom();
                    drawMap();
                }
            }
        });

        canvas.addEventListener('touchend', function(e) {
            if (e.touches.length < 2) {
                initialPinchDistance = null;
            }
        });
    </script>
</body>
</html>

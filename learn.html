<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Version: 2025-11-17 - PDF Deploy Fix -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bogus Basin Interactive Map</title>
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Cdefs%3E%3ClinearGradient id='sky' x1='0%25' y1='0%25' x2='0%25' y2='100%25'%3E%3Cstop offset='0%25' style='stop-color:%23667eea;stop-opacity:1'/%3E%3Cstop offset='100%25' style='stop-color:%23764ba2;stop-opacity:1'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect fill='url(%23sky)' width='64' height='64'/%3E%3Cpath fill='%235a67d8' d='M0 64 L20 30 L45 64 Z'/%3E%3Cpath fill='%236b7bb8' d='M15 64 L32 15 L55 64 Z'/%3E%3Cpath fill='%23ffffff' d='M32 15 L28 25 L32 22 L36 25 Z'/%3E%3Cpath fill='%23e0e7ff' d='M28 25 L32 22 L36 25 L40 35 L32 30 L24 35 Z'/%3E%3Cpath fill='%238b9dc3' d='M35 64 L48 35 L64 64 Z'/%3E%3Cpath fill='%23ffffff' d='M48 35 L46 40 L48 38 L50 40 Z'/%3E%3C/svg%3E">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }
        .container {
            max-width: 1800px;
            margin: 0 auto;
        }
        .header {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        .header h1 {
            color: #667eea;
            margin-bottom: 10px;
        }
        .mode-selector {
            display: flex;
            gap: 15px;
            margin-top: 15px;
        }
        .mode-btn {
            flex: 1;
            padding: 15px;
            border: 3px solid transparent;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-weight: 600;
        }
        .mode-btn.active {
            border-color: #667eea;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            transform: scale(1.05);
        }
        .mode-btn:not(.active) {
            background: #f1f5f9;
            color: #64748b;
        }
        .mode-btn:hover:not(.active) {
            background: #e2e8f0;
        }
        .progress-bar {
            width: 100%;
            height: 30px;
            background: #e2e8f0;
            border-radius: 15px;
            overflow: hidden;
            margin-top: 15px;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ade80 0%, #22c55e 100%);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
        .main-content {
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 20px;
            max-height: calc(100vh - 200px);
            min-height: 500px; /* Ensure minimum scrollable height */
            overflow: visible; /* Allow Safari to show scroll */
        }
        .sidebar {
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            max-height: 1200px; /* Limit sidebar height */
            min-height: 500px; /* Ensure scrollable area */
            overflow-y: visible; /* Let name-list-container handle scroll */
            -webkit-overflow-scrolling: touch;
        }
        .sidebar h2 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 1.2em;
            flex-shrink: 0;
        }
        .current-name {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            text-align: center;
            flex-shrink: 0;
        }
        .current-name .label {
            font-size: 0.85em;
            opacity: 0.9;
            margin-bottom: 3px;
        }
        .current-name .name {
            font-size: 1.5em;
            font-weight: bold;
        }
        .name-list-container {
            flex: 0 1 auto;
            max-height: 675px; /* Show exactly 15 items with scroll */
            height: 675px; /* Fixed height for scroll box */
            min-height: 0; /* Safari flexbox fix */
            overflow-y: scroll; /* Always show scrollbar */
            -webkit-overflow-scrolling: touch; /* Safari smooth scrolling */
            margin-top: 10px;
            padding-right: 5px;
        }
        .name-list-container::-webkit-scrollbar {
            width: 8px;
        }
        .name-list-container::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 10px;
        }
        .name-list-container::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 10px;
        }
        .name-list-container::-webkit-scrollbar-thumb:hover {
            background: #764ba2;
        }
        #namesList {
            width: 100%;
            min-height: 100px; /* Ensure content is visible in Safari */
        }
        .name-list-item {
            padding: 8px 10px;
            margin: 3px 0;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.9em;
            border-left: 4px solid transparent;
        }
        .name-list-item.completed {
            background: #d1fae5;
            border-left-color: #10b981;
            color: #065f46;
            cursor: default;
        }
        .name-list-item.current {
            background: #ddd6fe;
            border-left-color: #667eea;
            font-weight: bold;
            cursor: pointer;
        }
        .name-list-item.current:hover {
            background: #c4b5fd;
            transform: translateX(3px);
        }
        .name-list-item.pending {
            cursor: pointer;
        }
        .name-list-item.pending:hover {
            background: #e2e8f0;
            transform: translateX(3px);
            border-left-color: #94a3b8;
        }
        .name-list-item.incorrect {
            background: #fee2e2;
            border-left-color: #ef4444;
            color: #991b1b;
        }
        .name-list-item.pending {
            background: #f1f5f9;
            color: #64748b;
        }
        .name-list-item:hover {
            transform: translateX(5px);
        }
        .map-area {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            min-height: 1200px; /* Maximize map height */
            display: flex;
            flex-direction: column;
            overflow-y: auto; /* Allow scroll in Safari */
            -webkit-overflow-scrolling: touch;
        }
        .map-wrapper {
            position: relative;
            display: block;
            cursor: grab; /* Default grab cursor */
            width: 100%;
            max-height: none; /* Remove height restriction */
            min-height: 1100px; /* Ensure tall map box */
            overflow: auto; /* Auto scrollbars for better Mac compatibility */
            -webkit-overflow-scrolling: touch;
            touch-action: manipulation; /* Allow pinch-zoom and panning */
        }
        .map-wrapper:active {
            cursor: grabbing; /* Grabbing when mouse down */
        }
        .map-wrapper::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }
        .map-wrapper::-webkit-scrollbar-track {
            background: #f1f5f9;
        }
        .map-wrapper::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 6px;
        }
        .map-wrapper::-webkit-scrollbar-thumb:hover {
            background: #764ba2;
        }
        .map-wrapper.skis {
            cursor: grab;
        }
        .map-wrapper.skis:active {
            cursor: grabbing;
        }
        .map-wrapper.snowboard {
            cursor: grab;
        }
        .map-wrapper.snowboard:active {
            cursor: grabbing;
        }
        #mapCanvas {
            display: block;
            border: 2px solid #cbd5e1;
            border-radius: 8px;
            min-width: 100%; /* Ensure canvas can expand beyond container */
            min-height: 100%;
        }
        .instruction {
            background: #fef3c7;
            border-left: 4px solid #f59e0b;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 1.1em;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        .sidebar .controls {
            margin-bottom: 12px;
            flex-direction: column;
        }
        .map-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
            text-align: center;
        }
        .sidebar .btn {
            width: 100%;
        }
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .btn-success {
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
            color: white;
        }
        .btn-secondary {
            background: #94a3b8;
            color: white;
        }
        .btn-secondary.active {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            box-shadow: 0 0 15px rgba(34, 197, 94, 0.5);
        }
        .btn-danger {
            background: #ef4444;
            color: white;
        }
        .btn-warning {
            background: #f59e0b;
            color: white;
        }
        .btn-know-code {
            background: #fbbf24;
            color: #000000;
            font-weight: 700;
            padding: 12px 24px;
            border-radius: 8px;
            text-decoration: none;
            display: inline-block;
            transition: all 0.3s ease;
            border: none;
            cursor: pointer;
            font-size: 1em;
        }
        .btn-know-code:hover {
            background: #f59e0b;
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        .marker {
            position: absolute;
            width: 16px;
            height: 16px;
            background: #ef4444;
            border: 3px solid white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        .marker.correct {
            background: #22c55e;
        }
        .marker.incorrect {
            background: #ef4444;
        }
        .marker-label {
            position: absolute;
            background: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
            color: #334155;
            white-space: nowrap;
            pointer-events: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            border: 1px solid #cbd5e1;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-bottom: 12px;
            flex-shrink: 0;
        }
        .stat-box {
            background: #f8fafc;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid #e2e8f0;
        }
        .stat-value {
            font-size: 1.6em;
            font-weight: bold;
            color: #667eea;
        }
        .stat-value.correct {
            color: #22c55e;
        }
        .stat-value.incorrect {
            color: #ef4444;
        }
        .stat-label {
            font-size: 0.9em;
            color: #64748b;
            margin-top: 5px;
        }
        .result-message {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-weight: 600;
            text-align: center;
            display: none;
        }
        .result-message.show {
            display: block;
        }
        .result-message.perfect {
            background: #d1fae5;
            color: #065f46;
            border: 2px solid #22c55e;
        }
        .result-message.good {
            background: #dbeafe;
            color: #1e40af;
            border: 2px solid #3b82f6;
        }
        .result-message.try-again {
            background: #fee2e2;
            color: #991b1b;
            border: 2px solid #ef4444;
        }
        .feedback-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 30px 50px;
            border-radius: 15px;
            font-size: 2em;
            font-weight: bold;
            z-index: 1000;
            animation: popupFade 1s ease;
            pointer-events: none;
        }
        .feedback-popup.correct {
            background: #22c55e;
            color: white;
        }
        .feedback-popup.incorrect {
            background: #ef4444;
            color: white;
        }
        @keyframes popupFade {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            30% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            70% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }
        
        /* Mobile & Tablet Responsive Styles */
        @media screen and (max-width: 1024px) {
            body {
                padding: 10px;
            }
            
            .main-content {
                grid-template-columns: 1fr;
                height: auto;
                gap: 15px;
            }
            
            .sidebar {
                height: auto;
                max-height: none;
                min-height: 500px;
                order: 2;
            }
            
            .name-list-container {
                min-height: 250px;
            }
            
            .map-area {
                order: 1;
                height: auto;
            }
            
            .mode-selector {
                flex-direction: column;
                gap: 10px;
            }
            
            .mode-btn {
                padding: 12px;
                font-size: 0.95em;
            }
            
            /* Tablet button layout - 3 columns */
            .map-area .controls {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 10px;
            }
            
            .btn {
                padding: 12px 14px;
                font-size: 0.88em;
                min-height: 48px;
            }
            
            /* Sidebar buttons stay full width */
            .sidebar .controls {
                display: flex;
                flex-direction: column;
                gap: 10px;
            }
            
            .sidebar .btn {
                width: 100%;
                padding: 14px 16px;
                font-size: 0.95em;
            }
            
            .header h1 {
                font-size: 1.5em;
            }
            
            .stats {
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }
            
            .stat-value {
                font-size: 1.8em;
            }
            
            .current-name {
                padding: 15px;
            }
            
            .current-name .name {
                font-size: 1.5em;
            }
            
            .instruction {
                font-size: 0.95em;
                padding: 12px;
            }
            
            .feedback-popup {
                font-size: 1.5em;
                padding: 20px 35px;
            }
            
            /* Better touch targets for mobile */
            .name-item {
                min-height: 50px;
                padding: 12px;
                font-size: 1em;
            }
            
            .location-toggle label {
                padding: 10px 15px;
                font-size: 0.95em;
            }
        }
        
        /* Phone-specific styles */
        @media screen and (max-width: 600px) {
            body {
                padding: 5px;
            }
            
            .header {
                padding: 15px;
            }
            
            .header h1 {
                font-size: 1.2em;
                margin-bottom: 8px;
            }
            
            .sidebar {
                max-height: none;
                min-height: 400px;
                padding: 12px;
            }
            
            .sidebar h2 {
                font-size: 1em;
            }
            
            .name-list-container {
                min-height: 200px;
                max-height: none; /* Remove desktop scrollable constraint */
            }
            
            /* Reset map area to mobile-friendly sizes */
            .map-area {
                min-height: 400px !important;
            }
            
            .map-wrapper {
                min-height: 300px !important;
                max-height: none !important; /* Allow pinch zoom to expand */
                touch-action: manipulation !important; /* Ensure pinch-zoom works */
            }
            
            /* Sidebar buttons - full width, larger */
            .sidebar .controls {
                gap: 10px;
            }
            
            .sidebar .btn {
                padding: 14px 16px;
                font-size: 0.95em;
                min-height: 50px;
            }
            
            /* Map area controls - organized in rows */
            .map-area .controls {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 8px;
                justify-content: stretch;
            }
            
            .map-area .btn {
                padding: 12px 10px;
                font-size: 0.8em;
                min-height: 48px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            
            .stats {
                gap: 6px;
            }
            
            .stat-box {
                padding: 8px;
            }
            
            .stat-value {
                font-size: 1.4em;
            }
            
            .stat-label {
                font-size: 0.8em;
            }
            
            .current-name {
                padding: 12px;
            }
            
            .current-name .label {
                font-size: 0.9em;
            }
            
            .current-name .name {
                font-size: 1.3em;
            }
            
            .instruction {
                font-size: 0.85em;
                padding: 10px;
            }
            
            .progress-fill {
                font-size: 0.85em;
            }
            
            .name-item {
                min-height: 48px;
                padding: 10px;
                font-size: 0.95em;
            }
            
            .feedback-popup {
                font-size: 1.2em;
                padding: 15px 25px;
            }
            
            /* Make buttons easier to tap */
            button, .btn {
                min-height: 44px;
            }
            
            /* Adjust mode selector for smaller screens */
            .mode-btn {
                padding: 10px;
                font-size: 0.9em;
            }
            
            /* Compact layout adjustments */
            .main-content {
                gap: 10px;
            }
        }
        
        /* Landscape mobile orientation */
        @media screen and (max-height: 500px) and (orientation: landscape) {
            .header {
                padding: 10px;
                margin-bottom: 10px;
            }
            
            .header h1 {
                font-size: 1.1em;
                margin-bottom: 5px;
            }
            
            .mode-selector {
                flex-direction: row;
            }
            
            .sidebar {
                max-height: none;
                min-height: 300px;
            }
            
            .name-list-container {
                min-height: 150px;
            }
            
            .progress-bar {
                height: 20px;
                margin-top: 8px;
            }
            
            /* Increase map visibility in landscape */
            .map-wrapper {
                max-height: calc(100vh - 200px);
                min-height: 400px;
            }
        }
        
        /* Touch device optimizations */
        @media (hover: none) and (pointer: coarse) {
            /* Better touch targets */
            button, .btn, .name-item {
                min-height: 44px;
            }
            
            /* Prevent double-tap zoom */
            * {
                touch-action: manipulation;
            }
            
            /* Remove hover effects on touch devices */
            .btn:hover,
            .mode-btn:hover:not(.active),
            .name-item:hover {
                transform: none;
            }
            
            /* Add active/pressed state instead */
            .btn:active {
                transform: scale(0.95);
            }
            
            .name-item:active {
                background: #e0e7ff;
            }
        }
        
        /* Safari-specific fixes */
        @supports (-webkit-appearance: none) {
            .main-content {
                height: auto !important;
                max-height: none !important;
                min-height: 1200px !important;
            }
            
            .sidebar, .map-area {
                height: auto !important;
                max-height: none !important;
                min-height: 1000px !important;
            }
            
            .name-list-container {
                max-height: none !important;
                min-height: 800px !important;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>‚õ∑Ô∏è Bogus Basin Interactive Map</h1>
            <p>Learn the locations of all lifts and runs at Bogus Basin!</p>
        </div>

        <div id="practiceMode">
            <div class="main-content">
                <div class="sidebar">
                    <div class="current-name" id="currentNameBox">
                        <div class="label">Find this location:</div>
                        <div class="name" id="currentName">Alpine</div>
                    </div>

                    <div class="stats">
                        <div class="stat-box">
                            <div class="stat-value" id="completedCount">0</div>
                            <div class="stat-label">Completed</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="remainingCount">120</div>
                            <div class="stat-label">Remaining</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="percentComplete">0%</div>
                            <div class="stat-label">Progress</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="streakCount">0</div>
                            <div class="stat-label">Streak üî•</div>
                        </div>
                    </div>

                    <div class="controls" style="flex-direction: column; gap: 8px; flex-shrink: 0;">
                        <button class="btn btn-secondary" onclick="skipCurrent()" title="Skip this location and move to the next one">‚è≠Ô∏è Skip</button>
                        <button class="btn btn-secondary" onclick="scrambleList()" title="Shuffle the order of locations in the list below">üîÄ Scramble List</button>
                        <button class="btn btn-secondary" onclick="toggleMapText()" id="hideMapTextBtn" title="Hide trail and lift names printed on the map">üôà Hide Map Text</button>
                        <button class="btn btn-danger" onclick="resetPractice()" title="Start over from the beginning with a fresh session">üîÑ Reset</button>
                    </div>

                    <h2>Location List <span style="font-size: 0.7em; color: #64748b; font-weight: normal;">(click any to select)</span></h2>
                    
                    <!-- Search box -->
                    <div style="margin-bottom: 10px; position: relative;">
                        <input type="text" id="locationSearch" placeholder="üîç Search lifts, runs, lodges..." 
                               style="width: 100%; padding: 8px 30px 8px 12px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 14px; background: #f8fafc;" 
                               oninput="filterLocations()" onkeydown="handleSearchKeydown(event)" />
                        <button onclick="clearSearch()" id="clearSearchBtn" 
                                style="position: absolute; right: 5px; top: 50%; transform: translateY(-50%); background: none; border: none; cursor: pointer; font-size: 16px; color: #64748b; display: none;"
                                title="Clear search">‚úï</button>
                        <div id="searchResults" style="font-size: 12px; color: #64748b; margin-top: 4px;"></div>
                    </div>
                    
                    <div class="name-list-container">
                        <div id="namesList"></div>
                    </div>
                </div>

                <div class="map-area">
                    <div class="instruction">
                        üëÜ <strong>Click on the map</strong> where "<span id="instructionName">Alpine</span>" is located
                        <br><small style="opacity: 0.8;">üí° Tip: Turn on Auto-Zoom, then click any location in the list to jump right to it!</small>
                    </div>

                    <div class="controls map-controls">
                        <button class="btn btn-secondary" onclick="toggleRoute()" id="routeBtn" title="Show or hide the MTN Host Tour Route">üó∫Ô∏è MTN Host Tour Route</button>
                        <button class="btn btn-secondary" onclick="window.open('Mountain Tours Winter.pdf', '_blank')" title="View the Mountain Tours guide with tour descriptions and details">üìÑ Tour Guide</button>
                        <button class="btn btn-secondary" onclick="toggleAutoZoom()" id="autoZoomBtn" title="Automatically zoom to the current location when selected">ÔøΩ Auto-Zoom: OFF</button>
                        <button class="btn btn-secondary" onclick="toggleLabels()" id="labelsBtn" title="Show or hide location labels on the map">ÔøΩÔ∏è Labels</button>
                        <button class="btn btn-secondary" onclick="zoomIn()" title="Zoom in on the map (up to 1000%)">üîç+ Zoom In</button>
                        <button class="btn btn-secondary" onclick="zoomOut()" title="Zoom out on the map">üîç- Zoom Out</button>
                        <button class="btn btn-secondary" onclick="resetZoom()" title="Reset zoom level back to 100%">‚Ü∫ Reset Map</button>
                        <button class="btn btn-secondary" onclick="window.open('https://github.com/MountainsToGo/bbm/blob/main/USER_GUIDE.md', '_blank')" title="Open user guide in a new tab">üìñ User Guide</button>
                        <button class="btn btn-know-code" onclick="window.open('images/responsibility-code.jpg', '_blank')" title="View the ski/snowboard responsibility code">‚õ∑Ô∏è Know the Code</button>
                    </div>
                    
                    <div style="background: #f0f9ff; padding: 10px; border-radius: 6px; margin-bottom: 10px;">
                        <strong>Zoom Level:</strong> <span id="zoomLevel">100%</span> | 
                        <strong>Auto-Zoom:</strong> <span id="autoZoomStatus">OFF</span> | 
                        <strong>Tip:</strong> Use Ctrl+Scroll to zoom
                    </div>

                    <div class="map-wrapper" id="practiceMapWrapper">
                        <canvas id="mapCanvas"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="location_names.js"></script>
    <script>
        let currentMode = 'practice';
        let currentIndex = 0;
        let locations = [];
        let displayOrder = []; // Array of indices to control list display order (can be shuffled)
        let showLabels = false;
        let canvasScale = 1;
        let zoomLevel = 1.0;
        let correctCount = 0;
        let incorrectCount = 0;
        let streak = 0;
        let clickMarkers = []; // Store click markers for visual feedback
        let completedIndices = new Set(); // Track which locations were actually completed (not skipped)
        let skippedIndices = new Set(); // Track which locations were skipped
        let autoZoomEnabled = false; // Toggle for auto-zoom to selected location
        let highlightTimer = null; // Timer for temporary highlight
        let highlightedLocationIndex = null; // Track which location to highlight (for viewing completed items)
        let hideMapText = false; // Toggle to hide trail/lift names on the map image
        let textOverlays = []; // Array of overlay rectangles loaded from text_overlays.json
        let revealedOverlays = new Set(); // Track which overlays have been revealed by correct answers
        let routes = []; // Array of routes loaded from routes.json
        let showRoute = false; // Toggle to show/hide the MTN Host Tour Route
        
        // Route animation variables
        let routeAnimating = false;
        let animationSegment = 0; // Current segment being drawn (0 to waypoints.length-1)
        let animationProgress = 0; // Progress along current segment (0 to 1)
        let animationStartTime = 0;
        let flashPhase = 0; // 0=start flash, 1=drawing, 2=finish flash
        let flashStartTime = 0;
        let animationFrameId = null;
        
        // Celebration animation variables
        let celebrationActive = false;
        let celebrationStartTime = null;
        let skierTrail = [];
        let snowboarderTrail = [];
        let snowflakes = []; // Array of snowflakes for celebration

        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');
        const img = new Image();

        // Load image first
        img.onload = function() {
            // Use full image size - let CSS scale it down
            canvasScale = 1;
            
            canvas.width = img.width;  // 3131px
            canvas.height = img.height; // 1999px
            
            // Scale canvas to fit container using CSS transform
            canvas.style.width = '100%';
            canvas.style.height = 'auto';
            
            // Then load configuration with cache-busting
            const VERSION = '120locations'; // Update this to force cache refresh
            const cacheBuster = new Date().getTime();
            fetch(`bogus_basin_config.json?v=${VERSION}_${cacheBuster}`, {
                cache: 'no-cache',
                headers: {
                    'Cache-Control': 'no-cache, no-store, must-revalidate',
                    'Pragma': 'no-cache',
                    'Expires': '0'
                }
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Could not load JSON file');
                    }
                    return response.json();
                })
                .then(config => {
                    locations = config.locations;
                    console.log('RAW CONFIG LOADED - Total locations in JSON:', config.locations.length);
                    console.log('Locations array assigned:', locations.length);
                    if (locations.length === 0) {
                        alert('No locations found in configuration file!');
                        return;
                    }
                    
                    // Load text overlays configuration
                    return fetch('text_overlays.json?v=' + cacheBuster, {
                        cache: 'no-cache',
                        headers: {
                            'Cache-Control': 'no-cache, no-store, must-revalidate',
                            'Pragma': 'no-cache',
                            'Expires': '0'
                        }
                    });
                })
                .then(response => {
                    if (!response.ok) {
                        console.warn('No text overlays file found, continuing without overlays');
                        textOverlays = [];
                        initializeMode();
                        return null;
                    }
                    return response.json();
                })
                .then(overlayConfig => {
                    if (overlayConfig) {
                        textOverlays = overlayConfig.overlays || [];
                        console.log('Loaded', textOverlays.length, 'text overlays');
                    }
                    
                    // Load routes configuration
                    const routesCacheBuster = new Date().getTime();
                    return fetch('routes.json?v=' + routesCacheBuster, {
                        cache: 'no-cache',
                        headers: {
                            'Cache-Control': 'no-cache, no-store, must-revalidate',
                            'Pragma': 'no-cache',
                            'Expires': '0'
                        }
                    });
                })
                .then(response => {
                    if (!response.ok) {
                        console.warn('No routes file found, continuing without routes');
                        routes = [];
                        initializeMode();
                        return null;
                    }
                    return response.json();
                })
                .then(routesConfig => {
                    if (routesConfig && routesConfig.routes) {
                        routes = routesConfig.routes;
                        console.log('Loaded', routes.length, 'route(s)');
                    }
                    initializeMode();
                })
                .catch(err => {
                    console.error('Error loading config:', err);
                    
                    // Show helpful error message
                    const errorDiv = document.createElement('div');
                    errorDiv.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 15px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); max-width: 600px; z-index: 10000;';
                    errorDiv.innerHTML = `
                        <h2 style="color: #ef4444; margin-top: 0;">‚ö†Ô∏è Cannot Load Configuration</h2>
                        <p><strong>This app needs to run from a web server, not by opening the file directly.</strong></p>
                        <h3>Quick Fix - Option 1 (Python):</h3>
                        <ol>
                            <li>Open PowerShell in this folder</li>
                            <li>Run: <code style="background: #f1f5f9; padding: 4px 8px; border-radius: 4px;">python -m http.server 8000</code></li>
                            <li>Open browser to: <a href="http://localhost:8000/learn.html" target="_blank">http://localhost:8000/learn.html</a></li>
                        </ol>
                        <h3>Quick Fix - Option 2 (VS Code):</h3>
                        <ol>
                            <li>Install "Live Server" extension in VS Code</li>
                            <li>Right-click learn.html and select "Open with Live Server"</li>
                        </ol>
                        <button onclick="this.parentElement.remove()" style="padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; margin-top: 15px;">Close</button>
                    `;
                    document.body.appendChild(errorDiv);
                });
        };
        img.src = 'trail_map.png';

        function initializeMode() {
            currentIndex = 0;
            correctCount = 0;
            incorrectCount = 0;
            streak = 0;
            clickMarkers = [];
            completedIndices = new Set();
            skippedIndices = new Set();
            revealedOverlays = new Set(); // Reset revealed overlays on restart
            celebrationActive = false; // Stop celebration animation
            celebrationStartTime = null;
            skierTrail = [];
            snowboarderTrail = [];
            snowflakes = []; // Clear snowflakes
            
            if (locations.length === 0) {
                console.error('No locations loaded!');
                return;
            }
            
            // Keep locations in alphabetical order
            console.log('BEFORE SORT:', locations.length, 'locations');
            locations = [...locations].sort((a, b) => a.name.localeCompare(b.name));
            console.log('AFTER SORT:', locations.length, 'locations');
            
            // Initialize display order as sequential (0, 1, 2, ...)
            displayOrder = locations.map((_, index) => index);
            
            console.log('Initialized with', locations.length, 'locations');
            console.log('First location:', locations[0]);
            
            updateUI();
            drawMap();
        }

        function drawMap() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            
            // Draw black overlays to hide trail/lift text on map if enabled
            if (hideMapText && textOverlays.length > 0) {
                ctx.fillStyle = 'rgba(0, 0, 0, 1.0)';
                textOverlays.forEach((overlay, index) => {
                    // Skip overlays that have been revealed by correct answers
                    if (revealedOverlays.has(index)) {
                        return;
                    }
                    
                    ctx.save();
                    
                    // Apply rotation if specified
                    if (overlay.rotation) {
                        const centerX = (overlay.x + overlay.width / 2) * canvasScale;
                        const centerY = (overlay.y + overlay.height / 2) * canvasScale;
                        ctx.translate(centerX, centerY);
                        ctx.rotate((overlay.rotation * Math.PI) / 180);
                        ctx.translate(-centerX, -centerY);
                    }
                    
                    ctx.fillRect(
                        overlay.x * canvasScale,
                        overlay.y * canvasScale,
                        overlay.width * canvasScale,
                        overlay.height * canvasScale
                    );
                    
                    ctx.restore();
                });
            }
            
            // Draw white boxes at all location coordinates
            locations.forEach((loc, index) => {
                // Draw white boxes for pending and skipped locations (not completed)
                if (!completedIndices.has(index)) {
                    // Fixed box size in canvas coordinates - no scaling needed
                    // The CSS zoom will automatically scale the entire canvas
                    const baseBoxSize = 20;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; // More opaque
                    ctx.strokeStyle = '#ef4444';
                    ctx.lineWidth = 4; // Thicker border
                    ctx.fillRect(
                        loc.x * canvasScale - baseBoxSize/2,
                        loc.y * canvasScale - baseBoxSize/2,
                        baseBoxSize,
                        baseBoxSize
                    );
                    ctx.strokeRect(
                        loc.x * canvasScale - baseBoxSize/2,
                        loc.y * canvasScale - baseBoxSize/2,
                        baseBoxSize,
                        baseBoxSize
                    );
                }
            });
            
            // Draw click markers (X marks for correct/incorrect)
            clickMarkers.forEach(marker => {
                const size = 20;
                ctx.strokeStyle = marker.correct ? '#22c55e' : '#ef4444';
                ctx.lineWidth = 4;
                
                // Draw X
                ctx.beginPath();
                ctx.moveTo(marker.x - size/2, marker.y - size/2);
                ctx.lineTo(marker.x + size/2, marker.y + size/2);
                ctx.moveTo(marker.x + size/2, marker.y - size/2);
                ctx.lineTo(marker.x - size/2, marker.y + size/2);
                ctx.stroke();
                
                // Draw circle around it
                ctx.beginPath();
                ctx.arc(marker.x, marker.y, size, 0, 2 * Math.PI);
                ctx.stroke();
            });
            
            // Draw completed locations as green dots (only truly completed, not skipped)
            completedIndices.forEach(i => {
                const loc = locations[i];
                ctx.fillStyle = '#22c55e';
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(loc.x * canvasScale, loc.y * canvasScale, 8, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();

                if (showLabels) {
                    ctx.fillStyle = 'white';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 3;
                    ctx.font = 'bold 18px Arial';
                    const text = loc.name;
                    ctx.strokeText(text, loc.x * canvasScale + 12, loc.y * canvasScale + 4);
                    ctx.fillText(text, loc.x * canvasScale + 12, loc.y * canvasScale + 4);
                }
            });
            
            // Draw red highlight circle for current location if auto-zoom is enabled
            // OR for any highlighted location (including completed ones that were clicked)
            if (autoZoomEnabled) {
                const highlightIndex = highlightedLocationIndex !== null ? highlightedLocationIndex : currentIndex;
                if (highlightIndex < locations.length) {
                    const loc = locations[highlightIndex];
                    ctx.save();
                    
                    // Bold, bright red circles - tighter around location
                    ctx.strokeStyle = '#dc2626'; // Darker, bolder red
                    ctx.lineWidth = 6; // Thicker lines
                    ctx.setLineDash([8, 4]); // Shorter dashes for bolder look
                    
                    // Draw three tighter concentric circles for emphasis
                    for (let i = 1; i <= 3; i++) {
                        ctx.beginPath();
                        // Tighter circles: 20px base + 8px increments (was 30px + 15px increments)
                        ctx.arc(loc.x * canvasScale, loc.y * canvasScale, 20 + (i * 8), 0, 2 * Math.PI);
                        ctx.globalAlpha = 0.9 - (i * 0.15); // Higher opacity for bolder look
                        ctx.stroke();
                    }
                    
                    // Add a solid inner circle for maximum visibility
                    ctx.setLineDash([]); // Solid line
                    ctx.lineWidth = 4;
                    ctx.globalAlpha = 1.0;
                    ctx.beginPath();
                    ctx.arc(loc.x * canvasScale, loc.y * canvasScale, 15, 0, 2 * Math.PI);
                    ctx.stroke();
                    
                    ctx.restore();
                }
            }
            
            // Draw MTN Host Tour Route if enabled
            if (showRoute && routes.length > 0) {
                const route = routes.find(r => r.name === 'MTN Host Tour Route');
                if (route && route.waypoints && route.waypoints.length > 1) {
                    ctx.save();
                    
                    // Determine how much to draw based on animation state
                    let segmentsToDraw = route.waypoints.length - 1;
                    let partialProgress = 1;
                    
                    if (routeAnimating && flashPhase === 1) {
                        segmentsToDraw = animationSegment;
                        partialProgress = animationProgress;
                    }
                    
                    // Draw black lines connecting waypoints
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 6;
                    ctx.setLineDash([]);
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    
                    // Draw completed segments
                    for (let i = 0; i < segmentsToDraw; i++) {
                        ctx.beginPath();
                        ctx.moveTo(route.waypoints[i].x * canvasScale, route.waypoints[i].y * canvasScale);
                        ctx.lineTo(route.waypoints[i + 1].x * canvasScale, route.waypoints[i + 1].y * canvasScale);
                        ctx.stroke();
                    }
                    
                    // Draw partial segment if animating
                    if (routeAnimating && flashPhase === 1 && segmentsToDraw < route.waypoints.length - 1) {
                        const from = route.waypoints[segmentsToDraw];
                        const to = route.waypoints[segmentsToDraw + 1];
                        const partialX = from.x + (to.x - from.x) * partialProgress;
                        const partialY = from.y + (to.y - from.y) * partialProgress;
                        
                        ctx.beginPath();
                        ctx.moveTo(from.x * canvasScale, from.y * canvasScale);
                        ctx.lineTo(partialX * canvasScale, partialY * canvasScale);
                        ctx.stroke();
                    }
                    
                    // Draw red arrows between waypoints (only for completed segments)
                    const arrowSize = 20;
                    ctx.fillStyle = '#ef4444';
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    
                    const arrowsToDraw = routeAnimating && flashPhase === 1 ? segmentsToDraw : route.waypoints.length - 1;
                    
                    for (let i = 0; i < arrowsToDraw; i++) {
                        const from = route.waypoints[i];
                        const to = route.waypoints[i + 1];
                        
                        // Calculate midpoint
                        const midX = ((from.x + to.x) / 2) * canvasScale;
                        const midY = ((from.y + to.y) / 2) * canvasScale;
                        
                        // Calculate angle
                        const angle = Math.atan2(to.y - from.y, to.x - from.x);
                        
                        // Draw arrow
                        ctx.save();
                        ctx.translate(midX, midY);
                        ctx.rotate(angle);
                        
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(-arrowSize, -arrowSize / 2);
                        ctx.lineTo(-arrowSize, arrowSize / 2);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        
                        ctx.restore();
                    }
                    
                    // Draw waypoint markers
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    for (let i = 0; i < route.waypoints.length; i++) {
                        const wp = route.waypoints[i];
                        const x = wp.x * canvasScale;
                        const y = wp.y * canvasScale;
                        
                        if (i === 0) {
                            // START marker - big green flag with flash animation
                            ctx.save();
                            
                            // Flash effect during start phase
                            let opacity = 1;
                            if (routeAnimating && flashPhase === 0) {
                                const elapsed = Date.now() - flashStartTime;
                                const pulseSpeed = 300; // 300ms per pulse
                                const pulsePhase = (elapsed % pulseSpeed) / pulseSpeed;
                                opacity = 0.3 + 0.7 * Math.abs(Math.sin(pulsePhase * Math.PI));
                            }
                            
                            ctx.globalAlpha = opacity;
                            
                            // Draw flagpole
                            ctx.strokeStyle = '#000000';
                            ctx.lineWidth = 5;
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(x, y - 55);
                            ctx.stroke();
                            
                            // Draw flag
                            ctx.fillStyle = '#22c55e';
                            ctx.strokeStyle = '#000000';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.moveTo(x, y - 55);
                            ctx.lineTo(x + 40, y - 42);
                            ctx.lineTo(x, y - 29);
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                            
                            // Draw "START" text
                            ctx.fillStyle = '#22c55e';
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 4;
                            ctx.font = 'bold 22px Arial';
                            ctx.strokeText('START', x, y + 25);
                            ctx.fillText('START', x, y + 25);
                            
                            ctx.restore();
                        } else if (i === route.waypoints.length - 1) {
                            // FINISH marker - big checkered flag with flash animation
                            ctx.save();
                            
                            // Flash effect during finish phase
                            let opacity = 1;
                            if (routeAnimating && flashPhase === 2) {
                                const elapsed = Date.now() - flashStartTime;
                                const pulseSpeed = 300; // 300ms per pulse
                                const pulsePhase = (elapsed % pulseSpeed) / pulseSpeed;
                                opacity = 0.3 + 0.7 * Math.abs(Math.sin(pulsePhase * Math.PI));
                            }
                            
                            ctx.globalAlpha = opacity;
                            
                            // Draw flagpole
                            ctx.strokeStyle = '#000000';
                            ctx.lineWidth = 5;
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(x, y - 55);
                            ctx.stroke();
                            
                            // Draw checkered flag pattern (larger)
                            const flagWidth = 40;
                            const flagHeight = 24;
                            const checkSize = 10;
                            
                            for (let row = 0; row < 2; row++) {
                                for (let col = 0; col < 4; col++) {
                                    const isBlack = (row + col) % 2 === 0;
                                    ctx.fillStyle = isBlack ? '#000000' : '#ffffff';
                                    ctx.fillRect(
                                        x + (col * checkSize),
                                        y - 55 + (row * checkSize) + 7,
                                        checkSize,
                                        checkSize
                                    );
                                }
                            }
                            
                            // Border around flag
                            ctx.strokeStyle = '#000000';
                            ctx.lineWidth = 3;
                            ctx.strokeRect(x, y - 55 + 7, flagWidth, flagHeight);
                            
                            // Draw "FINISH" text
                            ctx.fillStyle = '#ef4444';
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 4;
                            ctx.font = 'bold 22px Arial';
                            ctx.strokeText('FINISH', x + 20, y + 25);
                            ctx.fillText('FINISH', x + 20, y + 25);
                            
                            ctx.restore();
                        } else {
                            // Regular numbered waypoint markers
                            ctx.fillStyle = '#ffffff';
                            ctx.strokeStyle = '#000000';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(x, y, 12, 0, 2 * Math.PI);
                            ctx.fill();
                            ctx.stroke();
                            
                            // Draw number
                            ctx.fillStyle = '#000000';
                            ctx.font = 'bold 14px Arial';
                            ctx.fillText((i + 1).toString(), x, y);
                        }
                    }
                    
                    ctx.restore();
                }
            }
            
            // Check if all locations completed - trigger celebration animation
            if (completedIndices.size === locations.length && !celebrationActive) {
                celebrationActive = true;
                celebrationStartTime = Date.now();
                // Initialize snowflakes
                initSnowflakes();
                requestAnimationFrame(animateCelebration);
            }
        }
        
        function initSnowflakes() {
            // Create 80 snowflakes with random positions
            snowflakes = [];
            for (let i = 0; i < 80; i++) {
                snowflakes.push({
                    x: Math.random() * img.width,
                    y: Math.random() * img.height,
                    speed: 1 + Math.random() * 2, // Fall speed
                    drift: (Math.random() - 0.5) * 0.5, // Horizontal drift
                    size: 3 + Math.random() * 4 // Size variation
                });
            }
        }
        
        function animateCelebration() {
            if (!celebrationActive) return;
            
            const elapsed = Date.now() - celebrationStartTime;
            const duration = 10000; // 10 seconds for smoother animation
            const progress = Math.min(elapsed / duration, 1);
            
            // Linear progress for most of the run, then speed up at the end
            let easedProgress;
            if (progress < 0.7) {
                // First 70% - constant speed
                easedProgress = progress;
            } else {
                // Last 30% - accelerate
                const endProgress = (progress - 0.7) / 0.3;
                easedProgress = 0.7 + (0.3 * endProgress * endProgress);
            }
            
            // Calculate Y position (top to bottom of map)
            const startY = 0;
            const endY = img.height;
            const currentY = startY + (endY - startY) * easedProgress;
            
            // Zigzag motion for realistic skiing
            const zigzagAmount = 100; // pixels
            const zigzagFrequency = 12; // More oscillations per descent (was 8)
            const zigzag = Math.sin(progress * Math.PI * zigzagFrequency) * zigzagAmount;
            
            // Multiple skiers/snowboarders with completely different diagonal paths - mixed up!
            const routes = [
                // Route 1: Snowboarder - far left to center-right (starts immediately)
                {
                    startX: img.width * 0.05,
                    endX: img.width * 0.65,
                    zigzag: zigzag * 1.2,
                    emoji: 'üèÇ',
                    name: 'snowboarder1',
                    delay: 0,      // No delay
                    duration: 1.0  // Normal speed
                },
                // Route 2: Skier - center to far left (starts 20% into animation)
                {
                    startX: img.width * 0.5,
                    endX: img.width * 0.1,
                    zigzag: -zigzag * 0.6,
                    emoji: '‚õ∑Ô∏è',
                    name: 'skier1',
                    delay: 0.2,    // Starts at 20% progress
                    duration: 0.8  // Faster
                },
                // Route 3: Snowboarder - right to center (starts 40% into animation)
                {
                    startX: img.width * 0.88,
                    endX: img.width * 0.45,
                    zigzag: -zigzag * 0.85,
                    emoji: 'üèÇ',
                    name: 'snowboarder2',
                    delay: 0.4,    // Starts at 40% progress
                    duration: 0.9  // Slightly faster
                },
                // Route 4: Skier - center-left to far right (starts 15% into animation)
                {
                    startX: img.width * 0.3,
                    endX: img.width * 0.9,
                    zigzag: zigzag * 0.75,
                    emoji: '‚õ∑Ô∏è',
                    name: 'skier2',
                    delay: 0.15,   // Starts at 15% progress
                    duration: 1.1  // Slightly slower
                },
                // Route 5: Skier - far right to center-left (starts 30% into animation)
                {
                    startX: img.width * 0.95,
                    endX: img.width * 0.35,
                    zigzag: -zigzag * 1.1,
                    emoji: '‚õ∑Ô∏è',
                    name: 'skier3',
                    delay: 0.3,    // Starts at 30% progress
                    duration: 0.85 // Faster
                },
                // Route 6: Snowboarder - center-left to right (starts 10% into animation)
                {
                    startX: img.width * 0.25,
                    endX: img.width * 0.8,
                    zigzag: zigzag * 0.9,
                    emoji: 'üèÇ',
                    name: 'snowboarder3',
                    delay: 0.1,    // Starts at 10% progress
                    duration: 1.05 // Slightly slower
                }
            ];
            
            // Store positions for each route with diagonal movement and timing
            const positions = [];
            routes.forEach(route => {
                // Calculate individual progress for this route based on delay and duration
                const routeProgress = (progress - route.delay) / route.duration;
                
                // Only show if route has started and not finished
                if (routeProgress >= 0 && routeProgress <= 1) {
                    // Use same easing for each route
                    let routeEasedProgress;
                    if (routeProgress < 0.7) {
                        routeEasedProgress = routeProgress;
                    } else {
                        const endProgress = (routeProgress - 0.7) / 0.3;
                        routeEasedProgress = 0.7 + (0.3 * endProgress * endProgress);
                    }
                    
                    const routeY = startY + (endY - startY) * routeEasedProgress;
                    const baseX = route.startX + (route.endX - route.startX) * routeEasedProgress;
                    
                    positions.push({
                        x: baseX + route.zigzag,
                        y: routeY,
                        emoji: route.emoji,
                        zigzag: route.zigzag
                    });
                }
            });
            
            // Add to trails (keeping for potential future use)
            skierTrail.push(positions[0]);
            snowboarderTrail.push(positions[1]);
            const trailLength = 15;
            if (skierTrail.length > trailLength) skierTrail.shift();
            if (snowboarderTrail.length > trailLength) snowboarderTrail.shift();
            
            // Redraw map with animation
            drawMap();
            
            // Save context for crisp rendering
            ctx.save();
            // ctx.imageSmoothingEnabled = false; // COMMENTED OUT - was causing blurriness with motion
            
            // Draw current position only (no trail to avoid blur)
            const emojiSize = 80; // Much bigger emojis
            ctx.font = `${emojiSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.globalAlpha = 1.0;
            
            // Draw each position with flipping based on zigzag direction
            positions.forEach(pos => {
                ctx.save();
                
                // Flip horizontally if moving left (negative zigzag)
                if (pos.zigzag < 0) {
                    // Translate to position, flip, then draw
                    ctx.translate(pos.x * canvasScale, pos.y * canvasScale);
                    ctx.scale(-1, 1); // Flip horizontally
                    ctx.fillText(pos.emoji, 0, 0);
                } else {
                    // Draw normally (facing right)
                    ctx.fillText(pos.emoji, pos.x * canvasScale, pos.y * canvasScale);
                }
                
                ctx.restore();
            });
            
            // Update and draw snowflakes
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            snowflakes.forEach(flake => {
                // Update position
                flake.y += flake.speed;
                flake.x += flake.drift;
                
                // Reset to top if fallen off bottom
                if (flake.y > img.height) {
                    flake.y = 0;
                    flake.x = Math.random() * img.width;
                }
                
                // Wrap around horizontally
                if (flake.x < 0) flake.x = img.width;
                if (flake.x > img.width) flake.x = 0;
                
                // Draw snowflake
                ctx.beginPath();
                ctx.arc(flake.x * canvasScale, flake.y * canvasScale, flake.size, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            ctx.restore();
            
            // Continue animation or restart immediately
            if (progress < 1) {
                requestAnimationFrame(animateCelebration);
            } else {
                // Loop the animation - restart immediately without pause
                if (completedIndices.size === locations.length) {
                    celebrationStartTime = Date.now();
                    skierTrail = [];
                    snowboarderTrail = [];
                    // Keep snowflakes falling, don't reset them
                    requestAnimationFrame(animateCelebration);
                }
            }
        }
        
        // Hidden keyboard shortcut to complete all locations (for testing)
        // Press Ctrl+Shift+Q to trigger
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey && e.shiftKey && e.key === 'Q') {
                e.preventDefault(); // Prevent any default browser behavior
                completeAll();
            }
        });

        canvas.addEventListener('click', function(e) {
            if (currentMode !== 'practice' || currentIndex >= locations.length) return;
            
            // Don't register clicks if user just finished dragging
            if (hasDragged) {
                console.log('‚ö†Ô∏è Click ignored - hasDragged flag was set');
                hasDragged = false; // Reset for next interaction
                return;
            }

            const rect = canvas.getBoundingClientRect();
            // Convert click coordinates to canvas coordinates
            // Scale from screen pixels to canvas pixels, accounting for zoom and canvas scaling
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const rawClickX = (e.clientX - rect.left) * scaleX;
            const rawClickY = (e.clientY - rect.top) * scaleY;
            
            // Convert to map coordinates (accounting for canvas scaling)
            const clickX = rawClickX / canvasScale;
            const clickY = rawClickY / canvasScale;

            // Increased tolerance in map coordinates for more forgiving clicking
            const baseTolerance = 150; // Increased from 120 for easier clicking
            const tolerance = baseTolerance;
            
            const correctLoc = locations[currentIndex];
            const distance = Math.sqrt(Math.pow(clickX - correctLoc.x, 2) + Math.pow(clickY - correctLoc.y, 2));
            
            // Only block clicks on completed locations if they're NOT the current target
            // and they're closer than the current target
            let blockedByCompleted = false;
            for (const i of completedIndices) {
                const completedLoc = locations[i];
                const distToCompleted = Math.sqrt(Math.pow(clickX - completedLoc.x, 2) + Math.pow(clickY - completedLoc.y, 2));
                
                // Only block if:
                // 1. Click is within tolerance of a completed location
                // 2. That completed location is CLOSER than the current target
                if (distToCompleted < tolerance && distToCompleted < distance) {
                    console.log('‚ö†Ô∏è Click blocked - closer to completed location:', completedLoc.name, '(dist:', Math.round(distToCompleted), ') than target:', correctLoc.name, '(dist:', Math.round(distance), ')');
                    blockedByCompleted = true;
                    break;
                }
            }
            
            if (blockedByCompleted) {
                return; // Don't process clicks on completed locations
            }
            
            console.log('üéØ CLICK REGISTERED');
            console.log('  Click at canvas coords:', Math.round(rawClickX), Math.round(rawClickY));
            console.log('  Map coords:', Math.round(clickX), Math.round(clickY));
            console.log('  Target:', correctLoc.name, 'at', correctLoc.x, correctLoc.y);
            console.log('  Distance:', Math.round(distance), 'px | Tolerance:', tolerance, 'px');
            console.log('  Scale X/Y:', scaleX.toFixed(3), '/', scaleY.toFixed(3), '| Zoom:', zoomLevel);
            console.log('  Rect:', Math.round(rect.width), 'x', Math.round(rect.height), '| Canvas:', canvas.width, 'x', canvas.height);

            const isCorrect = distance < tolerance;
            
            if (!isCorrect) {
                console.log('  ‚ùå MISS - Distance', Math.round(distance), '> Tolerance', tolerance);
            } else {
                console.log('  ‚úÖ HIT - Distance', Math.round(distance), '<= Tolerance', tolerance);
            }

            if (isCorrect) {
                showFeedback(true);
                correctCount++;
                streak++;
                
                // Mark this index as completed (not skipped)
                completedIndices.add(currentIndex);
                
                // Reveal ALL overlays for this location (some locations have multiple overlays)
                const currentLocationName = locations[currentIndex].name;
                textOverlays.forEach((overlay, index) => {
                    if (overlay.note === currentLocationName) {
                        revealedOverlays.add(index);
                    }
                });
                
                // Add ONE permanent green marker at the correct location (using canvas coordinates)
                clickMarkers.push({
                    x: correctLoc.x * canvasScale,
                    y: correctLoc.y * canvasScale,
                    correct: true,
                    permanent: true
                });
                
                // Move to next location in displayOrder (not alphabetically)
                moveToNextLocation();
            } else {
                showFeedback(false);
                incorrectCount++;
                streak = 0;
                
                // Add red marker temporarily (using raw canvas coordinates)
                clickMarkers.push({
                    x: rawClickX,
                    y: rawClickY,
                    correct: false
                });
                
                // Remove the incorrect marker after showing feedback
                setTimeout(() => {
                    clickMarkers = clickMarkers.filter(m => m.correct);
                    drawMap();
                }, 1000);
            }
            
            updateUI();
            drawMap();
        });

        // Mouse panning functionality
        let isPanning = false;
        let hasDragged = false; // Track if user actually dragged
        let panStartX = 0;
        let panStartY = 0;
        let scrollStartX = 0;
        let scrollStartY = 0;
        const MIN_DRAG_DISTANCE = 10; // Increased from 5 to reduce false positives

        const mapWrapper = document.getElementById('practiceMapWrapper'); // Used for both panning and touch

        mapWrapper.addEventListener('mousedown', function(e) {
            // Only pan with left mouse button
            if (e.button !== 0) return;
            
            isPanning = true;
            hasDragged = false; // Reset drag flag
            panStartX = e.clientX;
            panStartY = e.clientY;
            scrollStartX = mapWrapper.scrollLeft;
            scrollStartY = mapWrapper.scrollTop;
            
            // Don't prevent default immediately - let Mac trackpad scroll work
            // Only prevent when actual dragging starts
        });

        mapWrapper.addEventListener('mousemove', function(e) {
            if (!isPanning) return;
            
            const deltaX = panStartX - e.clientX;
            const deltaY = panStartY - e.clientY;
            
            // Check if user has moved enough to be considered a drag
            const dragDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            if (dragDistance > MIN_DRAG_DISTANCE) {
                hasDragged = true;
                mapWrapper.style.cursor = 'grabbing';
                console.log('üñ±Ô∏è Drag detected, distance:', Math.round(dragDistance), 'px');
            }
            
            // Only do manual scrolling if actually dragging (not just clicked)
            if (hasDragged) {
                mapWrapper.scrollLeft = scrollStartX + deltaX;
                mapWrapper.scrollTop = scrollStartY + deltaY;
            }
        });

        mapWrapper.addEventListener('mouseup', function(e) {
            if (isPanning) {
                isPanning = false;
                // Reset cursor - changeCursor will set the right one
                updateMapCursor();
                
                // Reset hasDragged after a short delay to allow click event to check it
                // but prevent it from blocking subsequent clicks
                setTimeout(() => {
                    hasDragged = false;
                    console.log('üîÑ Drag flag reset');
                }, 100);
            }
        });

        mapWrapper.addEventListener('mouseleave', function() {
            if (isPanning) {
                isPanning = false;
                updateMapCursor();
                // Also reset hasDragged when mouse leaves
                setTimeout(() => {
                    hasDragged = false;
                }, 100);
            }
        });
        
        // Helper function to update cursor based on current selection
        function updateMapCursor() {
            if (currentCursorType === 'skis' || currentCursorType === 'snowboard') {
                // Keep the class-based cursor
                mapWrapper.style.cursor = '';
            } else {
                mapWrapper.style.cursor = 'grab';
            }
        }

        function showFeedback(correct) {
            const popup = document.createElement('div');
            popup.className = `feedback-popup ${correct ? 'correct' : 'incorrect'}`;
            popup.textContent = correct ? '‚úì Correct!' : '‚úó Try Again';
            document.body.appendChild(popup);
            setTimeout(() => popup.remove(), 1000);
        }

        function updateUI() {
            if (currentIndex < locations.length) {
                document.getElementById('currentName').textContent = locations[currentIndex].name;
                document.getElementById('instructionName').textContent = locations[currentIndex].name;
            } else {
                document.getElementById('currentName').textContent = '‚úì Complete!';
                document.getElementById('instructionName').textContent = 'All locations learned';
                document.querySelector('.instruction').style.background = '#d1fae5';
                document.querySelector('.instruction').style.borderColor = '#10b981';
            }

            const completed = completedIndices.size;
            const remaining = locations.length - completed;
            const percent = Math.round((completed / locations.length) * 100);

            document.getElementById('completedCount').textContent = completed;
            document.getElementById('remainingCount').textContent = remaining;
            document.getElementById('percentComplete').textContent = percent + '%';
            document.getElementById('streakCount').textContent = streak;

            // Progress bar removed from UI
            // const progressBar = document.getElementById('progressBar');
            // progressBar.style.width = percent + '%';
            // progressBar.textContent = `${completed} / ${locations.length}`;

            updateList();
        }

        function updateList() {
            const list = document.getElementById('namesList');
            list.innerHTML = '';
            // Use displayOrder to control the order items appear in the list
            displayOrder.forEach(index => {
                const loc = locations[index];
                const item = document.createElement('div');
                item.className = 'name-list-item';
                
                if (completedIndices.has(index)) {
                    // Completed (correctly answered) - NOW CLICKABLE to zoom/view
                    item.classList.add('completed');
                    item.innerHTML = `‚úì ${loc.name}`;
                    item.style.cursor = 'pointer';
                    item.onclick = function() {
                        // Allow clicking completed items to zoom to them
                        highlightedLocationIndex = index; // Set which location to highlight
                        if (autoZoomEnabled) {
                            zoomToLocation(index);
                        }
                        // Don't change currentIndex, just zoom to view
                        drawMap();
                    };
                } else if (skippedIndices.has(index)) {
                    // Skipped - clickable to jump back to it
                    item.classList.add('pending');
                    item.innerHTML = `‚è≠Ô∏è ${loc.name}`;
                    item.style.cursor = 'pointer';
                    item.onclick = function() {
                        highlightedLocationIndex = null; // Reset to use currentIndex
                        currentIndex = index;
                        skippedIndices.delete(index); // Remove from skipped when retrying
                        if (autoZoomEnabled) {
                            zoomToLocation(index);
                        }
                        updateUI();
                        drawMap();
                    };
                } else if (index === currentIndex) {
                    // Current - clickable to stay on it
                    item.classList.add('current');
                    item.innerHTML = `‚Üí ${loc.name}`;
                    item.style.cursor = 'pointer';
                    item.onclick = function() {
                        // Allow re-selecting current item
                        highlightedLocationIndex = null; // Reset to use currentIndex
                        if (autoZoomEnabled) {
                            zoomToLocation(index);
                        }
                        updateUI();
                        drawMap();
                    };
                } else {
                    // Pending or not yet reached - make all clickable!
                    item.classList.add('pending');
                    item.innerHTML = loc.name;
                    item.style.cursor = 'pointer';
                    item.onclick = function() {
                        highlightedLocationIndex = null; // Reset to use currentIndex
                        currentIndex = index;
                        if (autoZoomEnabled) {
                            zoomToLocation(index);
                        }
                        updateUI();
                        drawMap();
                    };
                }
                
                list.appendChild(item);
            });
        }

        function showAnswer() {
            if (currentIndex >= locations.length) return;
            
            const loc = locations[currentIndex];
            
            // Draw the map first
            drawMap();
            
            // Draw a pulsing highlight on the correct location
            ctx.save();
            ctx.fillStyle = 'rgba(34, 197, 94, 0.5)';
            ctx.strokeStyle = '#22c55e';
            ctx.lineWidth = 4;
            
            // Draw large circle
            ctx.beginPath();
            ctx.arc(loc.x * canvasScale, loc.y * canvasScale, 40, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
            
            // Draw arrow pointing to location
            ctx.fillStyle = '#22c55e';
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.strokeText('‚Üì', loc.x * canvasScale, loc.y * canvasScale - 50);
            ctx.fillText('‚Üì', loc.x * canvasScale, loc.y * canvasScale - 50);
            
            // Draw label
            ctx.font = 'bold 16px Arial';
            ctx.fillStyle = 'white';
            ctx.strokeStyle = '#22c55e';
            ctx.lineWidth = 4;
            const text = loc.name + ' is here!';
            ctx.strokeText(text, loc.x * canvasScale, loc.y * canvasScale + 60);
            ctx.fillText(text, loc.x * canvasScale, loc.y * canvasScale + 60);
            
            ctx.restore();
            
            setTimeout(() => drawMap(), 3000);
        }

        // Helper function to move to the next incomplete location in displayOrder
        function moveToNextLocation() {
            // Find the current location's position in displayOrder
            const currentPosition = displayOrder.indexOf(currentIndex);
            
            // Start searching from the next position in displayOrder
            for (let i = currentPosition + 1; i < displayOrder.length; i++) {
                const locationIndex = displayOrder[i];
                // Find first location that isn't completed or skipped
                if (!completedIndices.has(locationIndex) && !skippedIndices.has(locationIndex)) {
                    currentIndex = locationIndex;
                    return;
                }
            }
            
            // If no incomplete locations found after current position, we've reached the end
            currentIndex = locations.length;
        }

        function skipCurrent() {
            if (currentIndex < locations.length) {
                skippedIndices.add(currentIndex);
                moveToNextLocation();
                streak = 0;
                updateUI();
                drawMap();
            }
        }

        function scrambleList() {
            // Fisher-Yates shuffle algorithm to randomize displayOrder
            const shuffled = [...displayOrder];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            displayOrder = shuffled;
            
            // After scrambling, jump to the first incomplete location in the new order
            for (let i = 0; i < displayOrder.length; i++) {
                const locationIndex = displayOrder[i];
                // Skip completed and skipped locations, find first pending location
                if (!completedIndices.has(locationIndex) && !skippedIndices.has(locationIndex)) {
                    currentIndex = locationIndex;
                    break;
                }
            }
            
            // Re-render the list with new order and update UI to show new current location
            updateUI();
            drawMap();
        }
        
        function completeAll() {
            // Mark all locations as completed for testing the celebration animation
            for (let i = 0; i < locations.length; i++) {
                completedIndices.add(i);
                // Reveal all overlays
                textOverlays.forEach((overlay, index) => {
                    revealedOverlays.add(index);
                });
            }
            currentIndex = locations.length; // Move past the last location
            updateUI();
            drawMap();
        }

        function toggleMapText() {
            hideMapText = !hideMapText;
            const btn = document.getElementById('hideMapTextBtn');
            
            if (hideMapText) {
                // Map text hidden
                btn.textContent = 'üëÅÔ∏è Show Map Text';
                btn.classList.remove('btn-secondary');
                btn.classList.add('btn-primary');
            } else {
                // Map text visible
                btn.textContent = 'üôà Hide Map Text';
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-secondary');
            }
            
            drawMap();
        }

        function resetPractice() {
            if (confirm('Start over from the beginning?')) {
                initializeMode();
            }
        }
        
        function filterLocations() {
            const searchTerm = document.getElementById('locationSearch').value.toLowerCase();
            const searchResults = document.getElementById('searchResults');
            
            if (searchTerm === '') {
                // Show all locations when search is empty
                displayOrder = [...Array(locations.length).keys()];
                updateList();
                searchResults.textContent = '';
                return;
            }
            
            // Filter locations based on search term
            const matchingIndices = [];
            locations.forEach((location, index) => {
                if (location.name.toLowerCase().includes(searchTerm)) {
                    matchingIndices.push(index);
                }
            });
            
            // Update display order to show only matching locations
            displayOrder = matchingIndices;
            updateList();
            
            // Update search results info
            if (matchingIndices.length === 0) {
                searchResults.textContent = 'No locations found';
                searchResults.style.color = '#ef4444';
            } else if (matchingIndices.length === 1) {
                searchResults.textContent = '1 location found';
                searchResults.style.color = '#22c55e';
            } else {
                searchResults.textContent = `${matchingIndices.length} locations found`;
                searchResults.style.color = '#22c55e';
            }
            
            // Show/hide clear button
            const clearBtn = document.getElementById('clearSearchBtn');
            clearBtn.style.display = searchTerm ? 'block' : 'none';
        }
        
        function clearSearch() {
            document.getElementById('locationSearch').value = '';
            filterLocations(); // This will reset to show all locations
            document.getElementById('locationSearch').focus();
        }
        
        function handleSearchKeydown(event) {
            // Clear search on Escape key
            if (event.key === 'Escape') {
                clearSearch();
            }
            // Jump to first result on Enter key
            else if (event.key === 'Enter') {
                const firstVisible = displayOrder[0];
                if (firstVisible !== undefined && autoZoomEnabled) {
                    zoomToLocation(firstVisible);
                    drawMap();
                }
            }
        }

        function toggleLabels() {
            showLabels = !showLabels;
            const btn = document.getElementById('labelsBtn');
            
            if (showLabels) {
                // Labels ON - show green
                btn.classList.remove('btn-secondary');
                btn.classList.add('btn-primary');
            } else {
                // Labels OFF - show gray
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-secondary');
            }
            
            drawMap();
        }

        function toggleRoute() {
            showRoute = !showRoute;
            const btn = document.getElementById('routeBtn');
            
            if (showRoute) {
                // Route ON - show green and start animation
                btn.classList.remove('btn-secondary');
                btn.classList.add('btn-primary');
                startRouteAnimation();
            } else {
                // Route OFF - show gray and stop animation
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-secondary');
                stopRouteAnimation();
                drawMap();
            }
        }
        
        function startRouteAnimation() {
            // Cancel any existing animation
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            
            // Reset animation state
            routeAnimating = true;
            animationSegment = 0;
            animationProgress = 0;
            flashPhase = 0; // Start with START flash
            flashStartTime = Date.now();
            animationStartTime = Date.now();
            
            // Start animation loop
            animateRouteFrame();
        }
        
        function stopRouteAnimation() {
            routeAnimating = false;
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }
        
        function animateRouteFrame() {
            if (!routeAnimating || !showRoute) return;
            
            const currentTime = Date.now();
            const route = routes.find(r => r.name === 'MTN Host Tour Route');
            
            if (!route || !route.waypoints || route.waypoints.length < 2) {
                stopRouteAnimation();
                return;
            }
            
            // Phase 0: Flash START (1 second)
            if (flashPhase === 0) {
                const elapsed = currentTime - flashStartTime;
                if (elapsed >= 1000) {
                    flashPhase = 1;
                    animationStartTime = currentTime;
                }
                drawMap();
                animationFrameId = requestAnimationFrame(animateRouteFrame);
                return;
            }
            
            // Phase 1: Draw route segments
            if (flashPhase === 1) {
                const segmentDuration = 1000; // 1000ms per segment
                const elapsed = currentTime - animationStartTime;
                
                // Calculate current segment and progress
                const totalElapsed = elapsed;
                const currentSegmentIndex = Math.floor(totalElapsed / segmentDuration);
                const progressInSegment = (totalElapsed % segmentDuration) / segmentDuration;
                
                animationSegment = currentSegmentIndex;
                animationProgress = progressInSegment;
                
                // Check if animation complete
                if (animationSegment >= route.waypoints.length - 1) {
                    animationSegment = route.waypoints.length - 1;
                    animationProgress = 1;
                    flashPhase = 2; // Move to finish flash
                    flashStartTime = currentTime;
                }
                
                drawMap();
                animationFrameId = requestAnimationFrame(animateRouteFrame);
                return;
            }
            
            // Phase 2: Flash FINISH (1 second)
            if (flashPhase === 2) {
                const elapsed = currentTime - flashStartTime;
                if (elapsed >= 1000) {
                    // Animation complete
                    stopRouteAnimation();
                    drawMap(); // Final draw with full route
                    return;
                }
                drawMap();
                animationFrameId = requestAnimationFrame(animateRouteFrame);
                return;
            }
        }

        function zoomIn() {
            zoomLevel = Math.min(10.0, zoomLevel + 0.25);
            applyZoom();
        }

        function zoomOut() {
            zoomLevel = Math.max(1.0, zoomLevel - 0.25); // Minimum zoom is 100%
            applyZoom();
        }

        function resetZoom() {
            zoomLevel = 1.0;
            
            // Restore to EXACT initial state (same as page load)
            canvas.style.width = '100%';
            canvas.style.height = 'auto';
            canvas.style.maxWidth = '';
            canvas.style.maxHeight = '';
            canvas.style.minWidth = '';
            canvas.style.minHeight = '';
            canvas.style.transform = '';
            canvas.style.aspectRatio = '';
            
            // Reset scroll position to top-left
            mapWrapper.scrollLeft = 0;
            mapWrapper.scrollTop = 0;
            
            // Update display
            document.getElementById('zoomLevel').textContent = '100%';
            
            // Force redraw
            drawMap();
        }

        function applyZoom() {
            // Use percentage-based sizing (matching initial setup)
            canvas.style.width = (100 * zoomLevel) + '%';
            canvas.style.height = 'auto';
            canvas.style.transform = 'none';
            document.getElementById('zoomLevel').textContent = Math.round(zoomLevel * 100) + '%';
        }

        function toggleAutoZoom() {
            autoZoomEnabled = !autoZoomEnabled;
            const btn = document.getElementById('autoZoomBtn');
            const status = document.getElementById('autoZoomStatus');
            
            if (autoZoomEnabled) {
                btn.textContent = 'üéØ Auto-Zoom: ON';
                btn.classList.add('active');
                status.textContent = 'ON';
                status.style.color = '#22c55e';
                status.style.fontWeight = 'bold';
                // Immediately zoom to current location
                zoomToLocation(currentIndex);
            } else {
                btn.textContent = 'üéØ Auto-Zoom: OFF';
                btn.classList.remove('active');
                status.textContent = 'OFF';
                status.style.color = '#64748b';
                status.style.fontWeight = 'normal';
                // Reset to normal view
                zoomLevel = 1.0;
                applyZoom();
                const mapWrapper = document.getElementById('practiceMapWrapper');
                mapWrapper.scrollLeft = 0;
                mapWrapper.scrollTop = 0;
                drawMap();
            }
        }

        function zoomToLocation(index) {
            if (index >= locations.length) return;
            
            const loc = locations[index];
            const mapWrapper = document.getElementById('practiceMapWrapper');
            
            // Set zoom level to 1.5x (less aggressive)
            zoomLevel = 1.5;
            applyZoom();
            
            // Calculate scroll position to center the location
            // Account for both canvas scale and zoom level
            const scaledX = loc.x * canvasScale * zoomLevel;
            const scaledY = loc.y * canvasScale * zoomLevel;
            
            const scrollX = scaledX - (mapWrapper.clientWidth / 2);
            const scrollY = scaledY - (mapWrapper.clientHeight / 2);
            
            mapWrapper.scrollLeft = Math.max(0, scrollX);
            mapWrapper.scrollTop = Math.max(0, scrollY);
            
            // Redraw with highlight
            drawMap();
        }

        let currentCursorType = 'default'; // Track current cursor selection

        function changeCursor(type) {
            const mapWrapper = document.getElementById('practiceMapWrapper');
            currentCursorType = type;
            
            // Remove all cursor classes
            mapWrapper.classList.remove('skis', 'snowboard');
            
            // Remove active class from all cursor buttons
            document.querySelectorAll('[onclick^="changeCursor"]').forEach(btn => {
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-secondary');
            });
            
            // Add the selected cursor class (all use grab/grabbing now)
            if (type === 'skis') {
                mapWrapper.classList.add('skis');
                document.getElementById('cursorType').textContent = 'Skier ‚õ∑Ô∏è';
                // Highlight the ski button
                document.querySelector('[onclick="changeCursor(\'skis\')"]').classList.remove('btn-secondary');
                document.querySelector('[onclick="changeCursor(\'skis\')"]').classList.add('btn-primary');
            } else if (type === 'snowboard') {
                mapWrapper.classList.add('snowboard');
                document.getElementById('cursorType').textContent = 'Snowboarder üèÇ';
                // Highlight the snowboard button
                document.querySelector('[onclick="changeCursor(\'snowboard\')"]').classList.remove('btn-secondary');
                document.querySelector('[onclick="changeCursor(\'snowboard\')"]').classList.add('btn-primary');
            } else {
                // Default to grab cursor (pointer finger style)
                document.getElementById('cursorType').textContent = 'Pointer üëÜ';
                // Highlight the default button
                document.querySelector('[onclick="changeCursor(\'default\')"]').classList.remove('btn-secondary');
                document.querySelector('[onclick="changeCursor(\'default\')"]').classList.add('btn-primary');
            }
            
            // Update the cursor
            updateMapCursor();
        }
        
        // Set default cursor on load
        changeCursor('default');

        canvas.addEventListener('wheel', function(e) {
            if (e.ctrlKey) {
                e.preventDefault();
                if (e.deltaY < 0) {
                    zoomIn();
                } else {
                    zoomOut();
                }
            }
        }, { passive: false });

        // Pinch-to-zoom for touch devices
        let initialPinchDistance = null;
        let initialZoomLevel = 1.0;

        canvas.addEventListener('touchstart', function(e) {
            if (e.touches.length === 2) {
                e.preventDefault();
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                initialPinchDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                initialZoomLevel = zoomLevel;
            }
        });

        canvas.addEventListener('touchmove', function(e) {
            if (e.touches.length === 2) {
                e.preventDefault();
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const currentDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                if (initialPinchDistance) {
                    const scale = currentDistance / initialPinchDistance;
                    const newZoom = initialZoomLevel * scale;
                    
                    // Clamp between 1.0x (100%) and 10x (1000%)
                    zoomLevel = Math.max(1.0, Math.min(10.0, newZoom));
                    
                    document.getElementById('zoomLevel').textContent = Math.round(zoomLevel * 100) + '%';
                    applyZoom();
                    drawMap();
                }
            }
        });

        canvas.addEventListener('touchend', function(e) {
            if (e.touches.length < 2) {
                initialPinchDistance = null;
            }
        });
    </script>
</body>
</html>
